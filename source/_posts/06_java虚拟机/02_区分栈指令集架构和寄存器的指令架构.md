---
title: 【Java虚拟机学习_02】JVM的架构模型
categories: Java虚拟机学习
tags:
  - 虚拟机
  - HotSpot VM
  - Java 虚拟机（JVM）
excerpt:  区分栈指令集架构和寄存器的指令架构
date: 2020-01-13 20:33:36
img:  /images/jvm/jvm.jpg
---

## JVM 的架构模型

Java 编译器输入的指令流基本上是一种基于**栈的指令集架构**，

另外一种指令集架构则是基于**寄存器的指令集架构**。

具体来说：这两种架构之间的区别：

### 基于栈式架构

- 设计和实现更简单，适用于资源受限的系统；
- 避开了寄存器的分配难题：使用零地址指令方式分配。
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
- 不需要硬件支持，可移植性更好，更好实现跨平台

### 基于寄存器架构

- 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作。
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主
### 举例
我们编写一个简单的代码，然后查看一下字节码的反编译后的结果
```java
public class Deno01 {
    public static void main(String[] args) {
        int x=1;
        int y=2;
        int z=x+y;
    }
}
```
然后我们找到编译后的 class 文件，使用下列命令进行反编译
```shell
  javap -v Deno01.class
```
得到的文件为:
```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_1       //0:常量x为1
         1: istore_1       //1:将x保存到素引为1的操作数据栈中     
         2: iconst_2       //2:常量y为2
         3: istore_2       //3:将y保存到素引为2的操作数据栈中     
         4: iload_1        //4:加载常量x
         5: iload_2        //5:加载常量y
         6: iadd           //6:加法操作
         7: istore_3       //7:将z保存到素引为3的操作数据栈中  
         8: return         //返回
      LineNumberTable:
        line 10: 0
        line 11: 2
        line 12: 4
        line 14: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            2       7     1     x   I
            4       5     2     y   I
            8       1     3     z   I
}
SourceFile: "Deno01.java"
```
而基于寄存器的计算流程
```
mov eax,1 //将eax寄存器的值设为1
1add eax,2 //使eax寄存器的值加2
```

### 总结
- 由于跨平台性的设计，Java 的指令都是根据栈来设计的。
- 不同平台 CPU 架构不同，所以不能设计为基于寄存器的。
- 优点是跨平台，指令集小，编译器容易实现
- 缺点是性能下降，实现同样的功能需要更多的指令。

### 问题
时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 `HotSpotVM` 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？

栈
跨平台性
指令集小
指令多
执行性能比寄存器差