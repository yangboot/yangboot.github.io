[{"authors":["admin"],"categories":null,"content":"Sherlock Holmes is a brilliant fictional detective created by the late 19th century British detective novelist Arthur Conan Doyle. Holmes claims to be a criminal investigation consultant, that is to say, when other detectives or private detectives encounter difficulties,\nthey often ask for help from him. Holmes can often solve many difficult problems without leaving home, but most of the stories focus on the more difficult cases that need Holmes to go out to investigate. Holmes is good at solving problems through observation, deductive reasoning and legal knowledge.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://academia-hugo.netlify.com/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Sherlock Holmes is a brilliant fictional detective created by the late 19th century British detective novelist Arthur Conan Doyle. Holmes claims to be a criminal investigation consultant, that is to say, when other detectives or private detectives encounter difficulties,\nthey often ask for help from him. Holmes can often solve many difficult problems without leaving home, but most of the stories focus on the more difficult cases that need Holmes to go out to investigate.","tags":null,"title":"My favorite","type":"authors"},{"authors":null,"categories":null,"content":"官网 https://prometheus.io/ ","date":1598313600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1598313600,"objectID":"81f2b5c4fa8dd8c677e1be4c639fc9f8","permalink":"https://academia-hugo.netlify.com/notes/prometheus/","publishdate":"2020-08-25T00:00:00Z","relpermalink":"/notes/prometheus/","section":"notes","summary":"Prometheus是一个开源的服务监控系统和时间序列数据库。","tags":null,"title":"prometheus监控学习","type":"docs"},{"authors":null,"categories":null,"content":"参考文档 spring-cloud-alibaba\n中文文档\nSpring Cloud Alibaba Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n参考文档 请查看 WIKI 。\n为 Spring Cloud Alibaba 贡献代码请参考 如何贡献 。\n主要功能  服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。  更多功能请参考 Roadmap。\n组件 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nNacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nRocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\nDubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。\nSeata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\nAlibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。\nAlibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。\nAlibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。\nAlibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。\n更多组件请参考 Roadmap。\n如何构建  master 分支对应的是 Spring Cloud Greenwich，最低支持 JDK 1.8。 finchley 分支对应的是 Spring Cloud Finchley，最低支持 JDK 1.8。 1.x 分支对应的是 Spring Cloud Edgware，最低支持 JDK 1.7。  Spring Cloud 使用 Maven 来构建，最快的使用方式是将本项目 clone 到本地，然后执行以下命令：\n./mvnw install\r执行完毕后，项目将被安装到本地 Maven 仓库。\n如何使用 如何引入依赖 如果需要使用已发布的版本，在 dependencyManagement 中添加如下配置。\n\u0026lt;dependencyManagement\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt;\r\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;\r\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/dependencyManagement\u0026gt;\r然后在 dependencies 中添加自己所需使用的依赖即可使用。\n演示 Demo 为了演示如何使用，Spring Cloud Alibaba 项目包含了一个子模块spring-cloud-alibaba-examples。此模块中提供了演示用的 example ，您可以阅读对应的 example 工程下的 readme 文档，根据里面的步骤来体验。\nExample 列表：\nSentinel Example\nNacos Config Example\nNacos Discovery Example\nRocketMQ Example\nSeata Example\nAlibaba Cloud OSS Example\nAlibaba Cloud ANS Example\nAlibaba Cloud ACM Example\nAlibaba Cloud SchedulerX Example\n版本管理规范 项目的版本号格式为 x.x.x 的形式，其中 x 的数值类型为数字，从 0 开始取值，且不限于 0~9 这个范围。项目处于孵化器阶段时，第一位版本号固定使用 0，即版本号为 0.x.x 的格式。\n由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此我们采取跟 SpringBoot 版本号一致的版本:\n 1.5.x 版本适用于 Spring Boot 1.5.x 2.0.x 版本适用于 Spring Boot 2.0.x 2.1.x 版本适用于 Spring Boot 2.1.x 2.2.x 版本适用于 Spring Boot 2.2.x  ","date":1596585600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1596585600,"objectID":"bb03a32af4282e2420bc869f3e334517","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/","publishdate":"2020-08-05T00:00:00Z","relpermalink":"/notes/cloud-albaba/","section":"notes","summary":"SSpring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。","tags":null,"title":"spring-cloud-Alibaba","type":"docs"},{"authors":null,"categories":null,"content":"简介 官网\nSpring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.\n","date":1594771200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1594771200,"objectID":"3c260cb62fc965b5760807660e6dd334","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/","publishdate":"2020-07-15T00:00:00Z","relpermalink":"/notes/cloud-study/","section":"notes","summary":"Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。","tags":null,"title":"SpringCloud微服务学习","type":"docs"},{"authors":null,"categories":null,"content":"Jenkins 官网：https://www.jenkins.io/\nBuild great things at any scale\nThe leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project\n","date":1593993600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1593993600,"objectID":"c787b878490c27afb993383ef717fc07","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/","publishdate":"2020-07-06T00:00:00Z","relpermalink":"/notes/jenkins-study/","section":"notes","summary":"Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能","tags":null,"title":"jenkins持续集成","type":"docs"},{"authors":null,"categories":null,"content":"简介 PaaS是（Platform as a Service）的缩写，是指平台即服务。 把服务器平台作为一种服务提供的商业模式，通过网络进行程序提供的服务称之为SaaS(Software as a Service)，而云计算时代相应的服务器平台或者开发环境作为服务进行提供就成为了PaaS(Platform as a Service)。\n所谓PaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。在2007年国内外SaaS厂商先后推出自己的PAAS平台。\n","date":1593648000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1593648000,"objectID":"af5e746201aec1ca06224fd7beaad25d","permalink":"https://academia-hugo.netlify.com/notes/paas-study/","publishdate":"2020-07-02T00:00:00Z","relpermalink":"/notes/paas-study/","section":"notes","summary":"PaaS是（Platform as a Service）的缩写是,指平台即服务","tags":null,"title":"PaaS平台即服务","type":"docs"},{"authors":null,"categories":null,"content":"shiro安全框架 官方开发文档：http://shiro.apache.org/architecture.html\nApache Shiro Architecture Apache Shiro’s design goals are to simplify application security by being intuitive and easy to use. Shiro’s core design models how most people think about application security - in the context of someone (or something) interacting with an application.\nSoftware applications are usually designed based on user stories. That is, you’ll often design user interfaces or service APIs based on how a user would (or should) interact with the software. For example, you might say, “If the user interacting with my application is logged in, I will show them a button they can click to view their account information. If they are not logged in, I will show a sign-up button.”\nThis example statement indicates that applications are largely written to satisfy user requirements and needs. Even if the ‘user’ is another software system and not a human being, you still write code to reflect behavior based on who (or what) is currently interacting with your software.\nShiro reflects these concepts in its own design. By matching what is already intuitive for software developers, Apache Shiro remains intuitive and easy to use in practically any application.\nHigh-Level Overview At the highest conceptual level, Shiro’s architecture has 3 primary concepts: the Subject, SecurityManager and Realms. The following diagram is a high-level overview of how these components interact, and we’ll cover each concept below:   ** Subject: As we’ve mentioned in our Tutorial, the Subject is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a Subject can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software.** Subject instances are all bound to (and require) a SecurityManager. When you interact with a Subject, those interactions translate to subject-specific interactions with the SecurityManager.\n  ** SecurityManager: The SecurityManager is the heart of Shiro’s architecture and acts as a sort of ’umbrella’ object that coordinates its internal security components that together form an object graph. However, once the SecurityManager and its internal object graph is configured for an application, it is usually left alone and application developers spend almost all of their time with the Subject API.**\nWe will talk about the SecurityManager in detail later on, but it is important to realize that when you interact with a Subject, it is really the SecurityManager behind the scenes that does all the heavy lifting for any Subject security operation. This is reflected in the basic flow diagram above.\n  ** Realms: Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.:**\nIn this sense a Realm is essentially a security-specific DAO: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The SecurityManager may be configured with multiple Realms, but at least one is required.\nShiro provides out-of-the-box Realms to connect to a number of security data sources (aka directories) such as LDAP, relational databases (JDBC), text configuration sources like INI and properties files, and more. You can plug-in your own Realm implementations to represent custom data sources if the default Realms do not meet your needs.\nLike other internal components, the Shiro SecurityManager manages how Realms are used to acquire security and identity data to be represented as Subject instances.\nDetailed Architecture The following diagram shows Shiro’s core architectural concepts followed by short summaries of each\n  Detailed Architecture The following diagram shows Shiro’s core architectural concepts followed by short summaries of each: ","date":1590364800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1590364800,"objectID":"1fa09a5150f0e4b8a40977e767feaa3f","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/","section":"notes","summary":"spring+shiro+thymeleaf用户登录授权","tags":null,"title":"spring+shiro+thymeleaf用户登录授权","type":"docs"},{"authors":null,"categories":null,"content":"简史 Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：Unix操作系统、MINIX操作系统、GNU计划、POSIX标准和Internet网络。\n20世纪80年代，计算机硬件的性能不断提高，PC的市场不断扩大，当时可供计算机选用的操作系统主要有Unix、DOS和MacOS这几种。Unix价格昂贵，不能运行于PC；DOS显得简陋，且源代码被软件厂商严格保密；MacOS是一种专门用于苹果计算机的操作系统。此时，计算机科学领域迫切需要一个更加完善、强大、廉价和完全开放的操作系统。由于供教学使用的典型操作系统很少，因此当时在荷兰当教授的美国人AndrewS.Tanenbaum编写了一个操作系统，名为MINIX，为了向学生讲述操作系统内部工作原理。MINIX虽然很好，但只是一个用于教学目的的简单操作系统，而不是一个强有力的实用操作系统，然而最大的好处就是公开源代码。全世界学计算机的学生都通过钻研MINIX源代码来了解电脑里运行的MINIX操作系统，芬兰赫尔辛基大学大学二年级的学生Linus Torvalds就是其中一个，在吸收了MINIX精华的基础上，Linus于1991年写出了属于自己的Linux操作系统，版本为Linux0.01，是Linux时代开始的标志。他利用Unix的核心，去除繁杂的核心程序，改写成适用于一般计算机的x86系统，并放在网络上供大家下载，1994年推出完整的核心Version1.0，至此，Linux逐渐成为功能完善、稳定的操作系统，并被广泛使用。\n（引用 ：https://baike.baidu.com/item/Linux）\nlinux之父 林纳斯·本纳第克特·托瓦兹——著名的电脑程序员、黑客。Linux内核的发明人及该计划的合作者。托瓦兹利用个人时间及器材创造出了这套当今全球最流行的操作系统（作业系统）内核之一。现受聘于开放源代码开发实验室（OSDL：Open Source Development Labs， Inc），全力开发Linux内核。 托瓦兹1969年12月28日出生于芬兰赫尔辛基市。父亲尼尔斯·托瓦兹（Nils Torvalds）是一名活跃的共产主义者及电台记者，曾当选芬兰共产党中央委员会委员。托瓦兹家族属于在芬兰占6%的少数民族芬兰瑞典人。他毕业于赫尔辛基大学计算机系，1997年至2003年在美国加州硅谷任职于全美达公司（Transmeta Corporation），现受聘于开放源代码开发实验（OSDL：Open Source Development Labs， Inc），全力开发Linux内核。与妻子托芙（Tove，芬兰前女子空手道冠军）育有三个女孩。\n与很多其他黑客不同，托瓦兹行事低调，一般很少评论商业竞争对手（例如微软）产品的好坏，但坚持开放源代码信念，并对微软等对手的FUD战略大为不满。\n例如，在一封回应微软资深副总裁Craig Mundie有关开放源代码运动的评论（Mundie批评开放源代码运动破坏了知识产权）的电子邮件中，托瓦兹写道：“我不知道Mundie是否听说过艾萨克·牛顿（Isaac Newton）爵士？他不仅因为创立了经典物理学（以及他和苹果的故事）而出名，也还因为说过这样一句话而闻名于世：我之所以能够看得更远，是因为我站在巨人肩膀上的缘故。”托瓦兹又说道：“我宁愿听牛顿的也不愿听Mundie的。他（牛顿）虽然死了快300年了，却也没有让房间这样得臭气熏天。”\n现年47岁的林纳斯目前受聘于开放源代码开发实验室（OSDL，Open Source Development Labs），全身心的开发Linux内核。尽管这位年轻人看上去毫不起眼，比如林纳斯曾在他的自传《乐者为王》（Just for Fun）中自嘲：“我是一个长相丑陋的孩子，凡是见过我小时候照片的人，都会觉得我的相貌酷似河狸。再想象一下我不修边幅的衣着，以及一个托瓦兹家族祖祖辈辈遗传下来的大鼻子，这样，在你脑海中我的模样就形成了。”但这丝毫也影响不了林纳斯对整个商业社会的巨大价值—Linux代表着网络时代新形式的开放知识产权形态，这将从根基上颠覆以Windows为代表的封闭式软件产权的传统商业模式。更重要的是，这样的颠覆早已悄悄的出现在了商业社会的各个角落\n独特见解 当在科技行业谈到实现名利的时候，一个有远见的，像史蒂夫·乔布斯一样伟大的人物浮现在我的脑海里，他通常能够设计出令人想不到的产品。但这也不是LinusTorvalds能够成为世界上最知名的程序员的理由（他经常与好莱坞明星在奥斯卡颁奖典礼上上亲密交谈）。\n当托瓦尔兹还是个大学生，他发明了开源的操作系统Linux，在当今世界的操作系统领域是最具生命力的（包括谷歌和Facebook均采用该操作系统）。世界上最快的超级计算机也采用该系统，同时，也是Android的核心。\n他于1991年发明该操作系统，描述该系统为“开源的操作系统，只是因为爱好，并且不会把它做得很大很专业”。Linux因为它的大和专业在当今世界是如此的重要。这是开源项目的典范，或者任何人都可以做出自己的贡献。自2005年以来，来自1200公司的近12000名程序员把他们的代码添加到主要的Linux操作系统（称为内核）。除了发明了操作系统，托瓦尔兹也发明了一种方，很多人一起工作在一个电脑程序项目。他发明的方法叫做Git，Git本身创建了自己的行业（从Torvalds没有获得任何帮助的情况下），但是如Github，提供给Git价值20亿美元的启动资金。\n托瓦尔兹说，如果他是一个有远见的人，那么这一切就不会发生。当他在一次和来自IEEE的斯蒂芬·卡斯采访中说到（和我们强调）：我相信，为了linux的成功，我不知道我自己究竟做了哪些。当我开始的时候，如果我坚信有一天我能成功，所以到现在我一直在坚持下去。有时候普你需要很多的自信，相信你能做到……\n事实上，我真的不知道它最终什么时候能够实现，意味着我会一直做下去。我可能会听取他人的建议，听取外部的意见，其他人加入该项目，我认为这样更容易，更有趣。有时候人们不需要别人的同意，但可以一直做自己喜欢的事情。\n引用：http://m.elecfans.com/article/633824.html/\n","date":1589846400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1589846400,"objectID":"90a528b4c5e28da8358ead96aa641f4c","permalink":"https://academia-hugo.netlify.com/notes/linux-study/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"/notes/linux-study/","section":"notes","summary":"主要学习 Centos 7.0 64位","tags":null,"title":"背景","type":"docs"},{"authors":null,"categories":null,"content":"前提条件   创建好Gitee账号\n  安装好git,VCode\n  根据开发文档建好HUGO站点\n  简介 Hugo是一种用 Go语言 编写的快速，现代化的 静态网站生成器 ，旨在让网站创建再次变得有趣。 Hugo是一个通用的网站框架。从技术上讲，Hugo是静态站点生成器。与根据每个访问者请求动态构建页面的系统不同，Hugo在创建或更新内容时会构建页面。由于浏览网站的频率远远高于编辑网站，因此Hugo旨在为您的网站的最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。\n使用Hugo构建的网站非常快速和安全。Hugo站点可以托管在任何地方，包括 Netlify ， Heroku ， GoDaddy ， DreamHost ， GitHub Pages ， GitLab Pages ， Surge ， Aerobatic ， Firebase ， Google Cloud Storage ， Amazon S3，Rackspace ， Azure 和 CloudFront ，并且可以与CDN很好地协作。Hugo网站的运行无需数据库或依赖于昂贵的运行时（如Ruby，Python或PHP）。\n我们认为Hugo是理想的网站创建工具，几乎可以立即构建，并且可以在进行更改时立即进行重建。\nGitee创建项目 注意路径最好跟用户名一致，不然到时候报404\n修改baseURL 修改站点下config.toml文件的baseURL\nbaseURL=\u0026#34;https://你仓库的路径.gitee.io\u0026#34; 初始化站点 在站点根目录执行hugo --theme=“你主题的名称”\nhugo --theme=academia 执行成功后,会在站点下会生成一个public的文件夹\n提交Gitee托管 在站点目录下右键git Bash 依次输入如下命令（如果是第一次的话要输入gitee账号的密码）\ngit pull //如果不行使用: git pull --rebase origin master git init git remote rm origin //改成自己的路径 git remote add origin https://XXX.com/XXXX/XXX.io.git git add -A git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 提交成功后上gitee检查，确保站点已经上传 Gitee部署 1.点击 “服务”\u0026ndash;\u0026raquo;\u0026quot;Gitee Pages\u0026rdquo; 2.部署目录输入“public”,勾选“强制使用HTTPS” 3.构建成功后输入链接即可访问 其他 启动hugo服务器\nhugo server -D hugo主题地址：https://themes.gohugo.io/\n","date":1588982400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"83747454804e4e9df6a158da8ce10c4c","permalink":"https://academia-hugo.netlify.com/notes/hugo-study/","publishdate":"2020-05-09T00:00:00Z","relpermalink":"/notes/hugo-study/","section":"notes","summary":"Hugo是一种用Go语言编写的快速，现代化的静态网站生成器，旨在让网站创建再次变得有趣","tags":null,"title":"在Gitee上部署hugo个人博客","type":"docs"},{"authors":null,"categories":null,"content":"docker架构 docker 包括三个基本概念:\n 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看着一个代码控制中心，用来保存镜像。     Docker 面向对象     容器 对象   镜像 类       概念 说明     Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。   Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。   Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。   Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。   Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \u0026lt;仓库名\u0026gt;:\u0026lt;标签\u0026gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。   Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。    ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"1751838582b5b48c7009f758105bce81","permalink":"https://academia-hugo.netlify.com/notes/docker-study/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/docker-study/","section":"notes","summary":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口","tags":null,"title":"doxker","type":"docs"},{"authors":null,"categories":null,"content":"yum安装jdk yum install java-1.8.0-openjdk* -y 手动安装 下载好jdk-8u112-linux-x64.tar.gz 提取码：liak\n下载好Xshell 6和Xftp 6提取码：9b13rvice\n上传安装包 使用Xftp连接云服务器，连接可能会出现\u0026quot;无法与XXX连接\u0026rdquo;，别慌\n执行以下命令，观察22号端口有没有被监听\nnetstat -anp | more 没有启动的话，重启一下\nservice sshd restart 安装 打开Xshell连接到服务器跳转到/opt目录下\ncd /opt 解压opt文件夹下的jdk-8u112-linux-x64.tar.gz文件\ntar -zxvf jdk-8u112-linux-x64.tar.gz 配置jdk环境变量 编辑/etc/目录下的profile文件\nvim /etc/profile 按下 Esc键 进入命令行模式 输入G 进入最后一行 按下 i 键进入编辑模式 ，输入以下配置\nJAVA_HOME=/opt/jdk1.8.0_112 PATH=/opt/jdk1.8.0_112/bin:$PATH export JAVA_HOME PATH 按下 Esc键 进入命令行模式，输入 wq! 强制退出保存，再logout注销命令\n重新登录后 输入java 输入javac 说明安装成功\n编写Hello vim /opt/Hello.java 按下 i 键进入编辑模式 ，输入以下配置\npublic class Hello{ public static void main (String[] args){ System.out.println(\u0026#34;Hellow\u0026#34;); } 按下 Esc键 进入命令行模式，输入 wq! 强制退出保存输入\njavac Hello.java ","date":1588633200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588633200,"objectID":"b9a8168a7b611d9d4f60cbbfa05a2346","permalink":"https://academia-hugo.netlify.com/notes/linux-study/%E5%AE%89%E8%A3%85jdk/","publishdate":"2020-05-05T00:00:00+01:00","relpermalink":"/notes/linux-study/%E5%AE%89%E8%A3%85jdk/","section":"notes","summary":"yum安装jdk yum install java-1.8.0-openjdk* -y 手动安装 下载好jdk-8u112-linux-x64.tar.gz 提取码：liak\n下载好Xshell 6和Xftp 6提取码：9b13rvice\n上传安装包 使用Xftp连接云服务器，连接可能会出现\u0026quot;无法与XXX连接\u0026rdquo;，别慌\n执行以下命令，观察22号端口有没有被监听\nnetstat -anp | more 没有启动的话，重启一下\nservice sshd restart 安装 打开Xshell连接到服务器跳转到/opt目录下\ncd /opt 解压opt文件夹下的jdk-8u112-linux-x64.tar.gz文件\ntar -zxvf jdk-8u112-linux-x64.tar.gz 配置jdk环境变量 编辑/etc/目录下的profile文件\nvim /etc/profile 按下 Esc键 进入命令行模式 输入G 进入最后一行 按下 i 键进入编辑模式 ，输入以下配置\nJAVA_HOME=/opt/jdk1.8.0_112 PATH=/opt/jdk1.8.0_112/bin:$PATH export JAVA_HOME PATH 按下 Esc键 进入命令行模式，输入 wq! 强制退出保存，再logout注销命令\n重新登录后 输入java 输入javac 说明安装成功\n编写Hello vim /opt/Hello.java 按下 i 键进入编辑模式 ，输入以下配置\npublic class Hello{ public static void main (String[] args){ System.","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":"hugo-academia主题添加代码块copy插件 效果 1.编写copy.css编写好后放入static/css目录下\ncopy.css .highlight { position: relative; } .highlight pre { padding-right: 75px; background-color:#f8f8f8 !important; } .highlight-copy-btn { position: absolute; bottom: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; color: #fff; background-color: #7777 min-width: 55px; text-align: center; } .highlight-copy-btn:hover { background-color: #666; } 2.编写copy.js编写好后放入static/js目录下\ncopy.js (function() { \u0026#39;use strict\u0026#39;; if(!document.queryCommandSupported(\u0026#39;copy\u0026#39;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function() { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild; copyBtn.addEventListener(\u0026#39;click\u0026#39;, function() { try { var selection = selectText(codeEl); document.execCommand(\u0026#39;copy\u0026#39;); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#39;Copied!\u0026#39;) } catch(e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#39;Failed :\\\u0026#39;(\u0026#39;) } }); containerEl.appendChild(copyBtn); } // Add copy button to code blocks  var highlightBlocks = document.getElementsByClassName(\u0026#39;highlight\u0026#39;); Array.prototype.forEach.call(highlightBlocks, addCopyButton); })(); 3.修改配置文件config.toml\nconfig.toml config.toml里添加下面这句引入copy.css\ncustom_css = [\u0026#34;/css/copy.css\u0026#34;] 4.引入copy.js 在主题文件夹下/layouts/partials/site_footer.html添加一行\nsite_footer.html \u0026lt;script src=\u0026#34;/js/copy.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"77ad45c1ea4ae8f4ea943211e5ba21d4","permalink":"https://academia-hugo.netlify.com/notes/hugo-study/hugo-academia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%9D%97copy%E6%8F%92%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/hugo-study/hugo-academia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E5%9D%97copy%E6%8F%92%E4%BB%B6/","section":"notes","summary":"hugo-academia主题添加代码块copy插件 效果 1.编写copy.css编写好后放入static/css目录下\ncopy.css .highlight { position: relative; } .highlight pre { padding-right: 75px; background-color:#f8f8f8 !important; } .highlight-copy-btn { position: absolute; bottom: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; color: #fff; background-color: #7777 min-width: 55px; text-align: center; } .highlight-copy-btn:hover { background-color: #666; } 2.编写copy.js编写好后放入static/js目录下\ncopy.js (function() { \u0026#39;use strict\u0026#39;; if(!document.queryCommandSupported(\u0026#39;copy\u0026#39;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function() { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.","tags":null,"title":"hugo-academia主题添加代码块copy插件","type":"docs"},{"authors":null,"categories":null,"content":"shiro+Thymeleaf授权  springboot-shiro-simple 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n 效果 导入Thymeleaf-shiro依赖 pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.theborakompanioni\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ShiroConfig.java //授权过滤器 filterMap.put(\u0026#34;/add\u0026#34;, \u0026#34;perms[user:add]\u0026#34;); filterMap.put(\u0026#34;/update\u0026#34;, \u0026#34;perms[user:update]\u0026#34;); //设置未授权URL shiroFilterFactoryBean.setUnauthorizedUrl(\u0026#34;/unAuth\u0026#34;); 编写授权逻辑 UserRealm.java protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { //给资源进行授权 \tSimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); Subject subject = SecurityUtils.getSubject(); User u=(User) subject.getPrincipal(); User user=userService.findByUsername(u.getUsername()); info.addStringPermission(user.getPerms()); return info; } 编写界面 通过shiro:hasPermission属性进行授权\n\u0026lt;div shiro:hasPermission=\u0026#34;user:add\u0026#34;\u0026gt;　\u0026lt;a href=\u0026#34;user/add\u0026#34;\u0026gt;用户添加\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:hasPermission=\u0026#34;user:update\u0026#34;\u0026gt;　\u0026lt;a href=\u0026#34;user/update\u0026#34;\u0026gt;用户修改\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a1d0338fa0e15ed8e7e735dbf0f73acf","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro+thymeleaf%E6%8E%88%E6%9D%83/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro+thymeleaf%E6%8E%88%E6%9D%83/","section":"notes","summary":"shiro+Thymeleaf授权  springboot-shiro-simple 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n 效果 导入Thymeleaf-shiro依赖 pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.theborakompanioni\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ShiroConfig.java //授权过滤器 filterMap.put(\u0026#34;/add\u0026#34;, \u0026#34;perms[user:add]\u0026#34;); filterMap.put(\u0026#34;/update\u0026#34;, \u0026#34;perms[user:update]\u0026#34;); //设置未授权URL shiroFilterFactoryBean.setUnauthorizedUrl(\u0026#34;/unAuth\u0026#34;); 编写授权逻辑 UserRealm.java protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { //给资源进行授权 \tSimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); Subject subject = SecurityUtils.getSubject(); User u=(User) subject.getPrincipal(); User user=userService.findByUsername(u.getUsername()); info.addStringPermission(user.getPerms()); return info; } 编写界面 通过shiro:hasPermission属性进行授权\n\u0026lt;div shiro:hasPermission=\u0026#34;user:add\u0026#34;\u0026gt;　\u0026lt;a href=\u0026#34;user/add\u0026#34;\u0026gt;用户添加\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div shiro:hasPermission=\u0026#34;user:update\u0026#34;\u0026gt;　\u0026lt;a href=\u0026#34;user/update\u0026#34;\u0026gt;用户修改\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; ","tags":null,"title":"shiro+Thymeleaf授权","type":"docs"},{"authors":null,"categories":null,"content":"shiro内置过滤器   anon:\t无需认证\n  authc:\t必需认证才可以访问\n  user:\t如果使用rememberMe的功能可以直接访问\n  perms:\t资源必需得到资源权限才可以访问\n  role: 该资源必需得到角色权限才能访问\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e71af0abcf46d5e86fd18a97a089744f","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8/","section":"notes","summary":"shiro内置过滤器   anon:\t无需认证\n  authc:\t必需认证才可以访问\n  user:\t如果使用rememberMe的功能可以直接访问\n  perms:\t资源必需得到资源权限才可以访问\n  role: 该资源必需得到角色权限才能访问\n  ","tags":null,"title":"shiro内置过滤器","type":"docs"},{"authors":null,"categories":null,"content":"shiro 常见的异常 (验证) authc: AuthencationException: AuthenticationException 异常是Shiro在登录认证过程中，认证失败需要抛出的异常。\nAuthenticationException包含以下子类：\n CredentitalsException 凭证异常\n IncorrectCredentialsException 不正确的凭证\n ExpiredCredentialsException 凭证过期\n AccountException 账号异常\n ConcurrentAccessException 并发访问异常（多个用户同时登录时抛出）\n UnknownAccountException 未知的账号\n ExcessiveAttemptsException 认证次数超过限制\n DisabledAccountException 禁用的账号 LockedAccountException 账号被锁定\nUnsupportedTokenException 使用了不支持的Token\nauthz: AuthorizationException: 子类: UnauthorizedException:抛出以指示请求的操作或对请求的资源的访问是不允许的。 UnanthenticatedException:当尚未完成成功认证时，尝试执行授权操作时引发异常。 (授权只能在成功的认证之后执行，因为授权数据（角色、权限等）必须总是与已知的标识相关联。这样的已知身份只能在成功登录时获得) 原文链接：https://blog.csdn.net/ssjq123/java/article/details/81086882\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6cdd24ca52fb2f68f6995f1f66966c8b","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/","section":"notes","summary":"shiro 常见的异常 (验证) authc: AuthencationException: AuthenticationException 异常是Shiro在登录认证过程中，认证失败需要抛出的异常。\nAuthenticationException包含以下子类：\n CredentitalsException 凭证异常\n IncorrectCredentialsException 不正确的凭证\n ExpiredCredentialsException 凭证过期\n AccountException 账号异常\n ConcurrentAccessException 并发访问异常（多个用户同时登录时抛出）\n UnknownAccountException 未知的账号\n ExcessiveAttemptsException 认证次数超过限制\n DisabledAccountException 禁用的账号 LockedAccountException 账号被锁定\nUnsupportedTokenException 使用了不支持的Token\nauthz: AuthorizationException: 子类: UnauthorizedException:抛出以指示请求的操作或对请求的资源的访问是不允许的。 UnanthenticatedException:当尚未完成成功认证时，尝试执行授权操作时引发异常。 (授权只能在成功的认证之后执行，因为授权数据（角色、权限等）必须总是与已知的标识相关联。这样的已知身份只能在成功登录时获得) 原文链接：https://blog.csdn.net/ssjq123/java/article/details/81086882","tags":null,"title":"shiro常见的异常","type":"docs"},{"authors":null,"categories":null,"content":"shiro无法依赖注入Service 这里是使用getBean()的方式\n添加工具类SpringBeanFactoryUtils @Component public class SpringBeanFactoryUtils implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (SpringBeanFactoryUtils.applicationContext == null) { SpringBeanFactoryUtils.applicationContext = applicationContext; } } public static ApplicationContext getApplicationContext() { return applicationContext; } //根据名称（@Resource 注解）  public static Object getBean(String name) { return getApplicationContext().getBean(name); } //根据类型（@Autowired）  public static \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; clazz) { return getApplicationContext().getBean(clazz); } public static \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; clazz) { return getApplicationContext().getBean(name, clazz); } } 调用 User u=SpringBeanFactoryUtils.getBean(IUserService.class).findByPhone(token.getUsername()); 如果用的的远程调用可以下面这样写java\nUser u = ApplicationContextProvider.getBean(IUserService.class) .findByPhone(token.getUsername()); ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"765ad40f3d5afee3b10242e4c81cabc3","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro%E6%97%A0%E6%B3%95%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5service/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro%E6%97%A0%E6%B3%95%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5service/","section":"notes","summary":"shiro无法依赖注入Service 这里是使用getBean()的方式\n添加工具类SpringBeanFactoryUtils @Component public class SpringBeanFactoryUtils implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (SpringBeanFactoryUtils.applicationContext == null) { SpringBeanFactoryUtils.applicationContext = applicationContext; } } public static ApplicationContext getApplicationContext() { return applicationContext; } //根据名称（@Resource 注解）  public static Object getBean(String name) { return getApplicationContext().getBean(name); } //根据类型（@Autowired）  public static \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; clazz) { return getApplicationContext().getBean(clazz); } public static \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; clazz) { return getApplicationContext().","tags":null,"title":"shiro无法依赖注入Service","type":"docs"},{"authors":null,"categories":null,"content":" springboot-shiro-realms 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n shiro用户名手机多Realm认证 效果 步骤 新建PhoneRealm 创建PhoneRealm.java修改认证方法\nUser u=SpringBeanFactoryUtils.getBean(IUserService.class).findByPhone(token.getUsername()); if (null == u||u.equals(\u0026#34;\u0026#34;)) { return null; } return\tnew SimpleAuthenticationInfo(u.getUsername(), u.getPassword(), ByteSource.Util.bytes(u.getSalt()), // 如果密码需要加盐验证，需要使用这个构造方法，后面会讲到。 \tgetName());JA 配置文件 .在src/main/resources下添加配置文件shiro.properties，如果 是多个realm用|隔开\n[main] shiro.realm.person=com.yzg.shiro.PhoneRealm 创建LoginConstants和LoginConfigurationBean用于解析配置文件\nLoginConstants\npublic interface LoginConstants { String CLASSPATH_SHIRO_PROPERTIES = \u0026#34;classpath:shiro.properties\u0026#34; ; } LoginConfigurationBean\npublic class LoginConfigurationBean { private static Props props = new Props(LoginConstants.CLASSPATH_SHIRO_PROPERTIES) ; public static String shiroRealm() { return props.getProperty(\u0026#34;shiro.realm.person\u0026#34;, \u0026#34;\u0026#34;) ; } } 修改ShiroConfig @Bean(name=\u0026#34;securityManager\u0026#34;) public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 添加多认证器 \tsecurityManager.setRealms(shiroRealmList()); return securityManager;} /** * 添加多个shiro认证方式 * * @return */ private Collection\u0026lt;Realm\u0026gt; shiroRealmList() { List\u0026lt;Realm\u0026gt; realms = new ArrayList\u0026lt;Realm\u0026gt;(); realms.add(shiroRealm()); // 读取系统[shiro.ini]配置 \trealms.add(new IniRealm(LoginConstants.CLASSPATH_SHIRO_PROPERTIES)); String personRealm = LoginConfigurationBean.shiroRealm(); try { String realmArr[] = personRealm.split(\u0026#34;\\\\|\u0026#34;); if (realmArr != null \u0026amp;\u0026amp; realmArr.length \u0026gt; 0) { for (String s : realmArr) { System.out.println(\u0026#34;realm:\u0026#34;+s); if (!(s==null||s.equals(\u0026#34;\u0026#34;))) { AuthorizingRealm pRealm = (AuthorizingRealm) Class.forName(s).newInstance(); realms.add(pRealm); } } } } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) { } return realms; } ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9b4e8108500ed0a22924f818a41cb8b1","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro%E7%94%A8%E6%88%B7%E5%90%8D%E6%89%8B%E6%9C%BA%E5%A4%9Arealm%E8%AE%A4%E8%AF%81/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro%E7%94%A8%E6%88%B7%E5%90%8D%E6%89%8B%E6%9C%BA%E5%A4%9Arealm%E8%AE%A4%E8%AF%81/","section":"notes","summary":"springboot-shiro-realms 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n shiro用户名手机多Realm认证 效果 步骤 新建PhoneRealm 创建PhoneRealm.java修改认证方法\nUser u=SpringBeanFactoryUtils.getBean(IUserService.class).findByPhone(token.getUsername()); if (null == u||u.equals(\u0026#34;\u0026#34;)) { return null; } return\tnew SimpleAuthenticationInfo(u.getUsername(), u.getPassword(), ByteSource.Util.bytes(u.getSalt()), // 如果密码需要加盐验证，需要使用这个构造方法，后面会讲到。 \tgetName());JA 配置文件 .在src/main/resources下添加配置文件shiro.properties，如果 是多个realm用|隔开\n[main] shiro.realm.person=com.yzg.shiro.PhoneRealm 创建LoginConstants和LoginConfigurationBean用于解析配置文件\nLoginConstants\npublic interface LoginConstants { String CLASSPATH_SHIRO_PROPERTIES = \u0026#34;classpath:shiro.properties\u0026#34; ; } LoginConfigurationBean\npublic class LoginConfigurationBean { private static Props props = new Props(LoginConstants.CLASSPATH_SHIRO_PROPERTIES) ; public static String shiroRealm() { return props.getProperty(\u0026#34;shiro.realm.person\u0026#34;, \u0026#34;\u0026#34;) ; } } 修改ShiroConfig @Bean(name=\u0026#34;securityManager\u0026#34;) public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 添加多认证器 \tsecurityManager.","tags":null,"title":"shiro用户名手机多Realm认证","type":"docs"},{"authors":null,"categories":null,"content":" springboot-shiro-md5 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n 效果 什么是MD5 MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。\n什么是盐值 就好比做菜，盐饭得多少菜的味道都不一样，同样的加密算法盐值不一样，得到的密文也不一样\n编写加密工具类 public static String shiroEncryption(String password,String salt) { // shiro 自带的工具类生成salt \t//String salt = new SecureRandomNumberGenerator().nextBytes().toString(); \t// 加密次数 \tint times = 1024; // 算法名称 \tString algorithmName = \u0026#34;md5\u0026#34;; //shiro自帶MD5加密 \tString encodedPassword = new SimpleHash(algorithmName,password,salt,times).toString(); // 返回加密后的密码 \treturn encodedPassword;\t} 用戶注冊 @RequestMapping(\u0026#34;/save\u0026#34;) public String save(Model model,User user) { String password=user.getPassword(); //密码加密 \tString salt = new SecureRandomNumberGenerator().nextBytes().toString(); String md5password = ShiroEncryption.shiroEncryption(password, salt); user.setSalt(salt); user.setPassword(md5password); userService.save(user); return \u0026#34;register\u0026#34;; } 修改ShiroConfig 思路：注册的密码是进行加密存入数据库的，所登录的时候也需要将用户输入的密码进行加密后比对\nshiro有自帶的密碼比對的方法SimpleCredentialsMatcher()需要修改比对方法，使用的是hashedCredentialsMatcher()所以在ShiroConfig写hashedCredentialsMatcher()方法时加密次数.算法名称都需要跟注册的一致。\n@Bean public HashedCredentialsMatcher hashedCredentialsMatcher() { HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(\u0026#34;md5\u0026#34;); hashedCredentialsMatcher.setHashIterations(1024); return hashedCredentialsMatcher; } 修改Realm 修改返回的构造方法\nreturn\tnew SimpleAuthenticationInfo(\u0026#34;数据库存的用户名\u0026#34;, \u0026#34;数据库存的密码\u0026#34;, ByteSource.Util.bytes(\u0026#34;数据库存的盐值\u0026#34;), getName()); ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5aa0c794483fb52ba69bbee51596b2ef","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/shiro%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8Cmd5%E5%8A%A0%E5%AF%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/shiro%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8Cmd5%E5%8A%A0%E5%AF%86/","section":"notes","summary":"springboot-shiro-md5 项目git地址：https://gitee.com/MrPen/springboot-shiro.git\n 效果 什么是MD5 MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。\n什么是盐值 就好比做菜，盐饭得多少菜的味道都不一样，同样的加密算法盐值不一样，得到的密文也不一样\n编写加密工具类 public static String shiroEncryption(String password,String salt) { // shiro 自带的工具类生成salt \t//String salt = new SecureRandomNumberGenerator().nextBytes().toString(); \t// 加密次数 \tint times = 1024; // 算法名称 \tString algorithmName = \u0026#34;md5\u0026#34;; //shiro自帶MD5加密 \tString encodedPassword = new SimpleHash(algorithmName,password,salt,times).toString(); // 返回加密后的密码 \treturn encodedPassword;\t} 用戶注冊 @RequestMapping(\u0026#34;/save\u0026#34;) public String save(Model model,User user) { String password=user.","tags":null,"title":"shiro登录注册MD5加密","type":"docs"},{"authors":null,"categories":null,"content":"效果 包结构 导入依赖 pom.xml \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 继承springboot父工程 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.yzg\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springboot-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 导入thymeleaf依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入WEB支持 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入shiro依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入阿里巴巴连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入MyBatis启动器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入mysql连接数据库驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 修改JDK版本 --\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 修改thymeleaf版本 --\u0026gt; \u0026lt;thymeleaf.version\u0026gt;3.0.2.RELEASE\u0026lt;/thymeleaf.version\u0026gt; \u0026lt;thymeleaf-layout-dialect.version\u0026gt;2.1.1\u0026lt;/thymeleaf-layout-dialect.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/project\u0026gt; 编写application.properties配置文件 server.port=8081 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/spring_shiro?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;characterSetResults=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT spring.datasource.username=数据库账号 spring.datasource.password=数据库密码 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource mybatis.type-aliases-package=com.yzg.domain 编写shiro配置类  创建ShiroFilterFactoryBean 创建DefaultWebSecurityManager 创建Realm  ShiroConfig.javajie shiroFilterFactoryBean.setLoginUrl(\u0026quot;/tologin\u0026rdquo;);是只定义登录连接，没有授权登录的都会请求这个这个链接\n@Configuration public class ShiroConfig { /** * 创建ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean( @Qualifier(\u0026#34;securityManager\u0026#34;) DefaultWebSecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); Map\u0026lt;String,String\u0026gt;filterMap=new LinkedHashMap\u0026lt;String,String\u0026gt;(); //放行 \tfilterMap.put(\u0026#34;/login\u0026#34;, \u0026#34;anon\u0026#34;); filterMap.put(\u0026#34;/testThymeleaf\u0026#34;, \u0026#34;anon\u0026#34;); //拦截 \tfilterMap.put(\u0026#34;/*\u0026#34;, \u0026#34;authc\u0026#34;); //修改用户登录界面路径 \tshiroFilterFactoryBean.setLoginUrl(\u0026#34;/tologin\u0026#34;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); shiroFilterFactoryBean.setSecurityManager(securityManager); return shiroFilterFactoryBean; } /** * 创建DefaultWebSecurityManager */ @Bean(name = \u0026#34;securityManager\u0026#34;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\u0026#34;userRealm\u0026#34;) UserRealm userRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; } /** * 创建Realm */ @Bean(name = \u0026#34;userRealm\u0026#34;) public UserRealm getRealm() { return new UserRealm(); } } 自定义realm   doGetAuthorizationInfo() 执行授权逻辑\n  doGetAuthenticationInfo() 执行认证逻辑\n  UserRealm。java SimpleAuthenticationInfo()第一个参数存放的是token相当于session第二个参数存放的是存放的是从数据库查询到的密码，在Realm中只需要输入界面用户输入的token和查询数据库获得的User对象shiro会帮你比对用户名和密码。\npublic class UserRealm extends AuthorizingRealm{ @Autowired private IUserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { System.out.println(\u0026#34;执行授权逻辑\u0026#34;); return null;t } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken agrs) throws AuthenticationException { System.out.println(\u0026#34;执行认证逻辑\u0026#34;);\t//编写shiro判断逻辑 \t//1.判断用户名 \tUsernamePasswordToken token=(UsernamePasswordToken)agrs; User u=userService.findByUsername(token.getUsername()); System.out.println(\u0026#34;用户\u0026#34;+u+\u0026#34;登录\u0026#34;); if(u==null||u.equals(\u0026#34;\u0026#34;)) { //用户名不存在 \treturn null; } //password是数据库的密码 \treturn new SimpleAuthenticationInfo(u,u.getPassword(), \u0026#34;\u0026#34;); } } 数据库设计 编写User实体类 public class User { private Integer id; private String username; private String password; private String name; private String perms; public String getPerms() { return perms; } public void setPerms(String perms) { this.perms = perms; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getName() { return name; } public void setName(String name) { this.name = name; } 编写mapper层 UserMapper.java public interface UserMapper { User findByUsername(String username); } UserMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.yzg.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;findByUsername\u0026#34; parameterType=\u0026#34;string\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT id, name, username, password, perms FROM user WHERE username = \u0026#34;${value}\u0026#34; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 编写service层 IUserService.java public interface IUserService { User findByUsername(String username); } UserServiceImpl.java @Service public class UserServiceImpl implements IUserService{ @Autowired private UserMapper userMapper; @Override public User findByUsername(String username) { return userMapper.findByUsername(username); } } 编写controller层 shiro是通过捕获异常的方式判断进行登录认证的\nUserController @Controller public class UserController { /** * 登录逻辑处理 * @return */ @RequestMapping(\u0026#34;/login\u0026#34;) public String login(String username, String password, Model model) { Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); try { subject.login(token); return \u0026#34;redirect:/testThymeleaf\u0026#34;; } catch (UnknownAccountException e) { System.out.println(\u0026#34;用户名不存在\u0026#34;); model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;用户名不存在\u0026#34;); return \u0026#34;login\u0026#34;; }catch (IncorrectCredentialsException e) { System.out.println(\u0026#34;密码错误\u0026#34;); model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;密码错误\u0026#34;); return \u0026#34;login\u0026#34;; } } @RequestMapping(\u0026#34;/test\u0026#34;) public String testThymeleaf(Model model) { return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/user/add\u0026#34;) public String add() { return \u0026#34;user/add\u0026#34;; } @RequestMapping(\u0026#34;/user/update\u0026#34;) public String update() { return \u0026#34;user/update\u0026#34;; } @RequestMapping(\u0026#34;/tologin\u0026#34;) public String tologin() { return \u0026#34;login\u0026#34;; } } 编写界面 首页 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\u0026lt;/meta\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3 th:text=\u0026#34;${name}\u0026#34;\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;a href=\u0026#34;user/add\u0026#34;\u0026gt;用户添加\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;user/update\u0026#34;\u0026gt;用户修改\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;tologin\u0026#34;\u0026gt;登錄\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; login.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\u0026lt;/meta\u0026gt; \u0026lt;title\u0026gt;用户登录\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;用户登录\u0026lt;/h3\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;login\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;color:red\u0026#34; th:text=\u0026#34;${msg}\u0026#34;\u0026gt;\u0026lt;/h3\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登录\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用户添加 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户添加\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 用户添加 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 用户修改 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;用户修改\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 用户修改 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"645a1364100b1b87c1338c976bb6895f","permalink":"https://academia-hugo.netlify.com/notes/spring-shiro-thymeleaf/%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/spring-shiro-thymeleaf/%E7%AE%80%E5%8D%95%E7%99%BB%E5%BD%95/","section":"notes","summary":"效果 包结构 导入依赖 pom.xml \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 继承springboot父工程 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.yzg\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springboot-shiro\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 导入thymeleaf依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入WEB支持 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入shiro依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入阿里巴巴连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入MyBatis启动器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入mysql连接数据库驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 修改JDK版本 --\u0026gt; \u0026lt;java.","tags":null,"title":"spring+shiro+MyBatis实现登录认证","type":"docs"},{"authors":null,"categories":null,"content":"Linux vi/vim 转载：https://www.runoob.com/linux/linux-vim.html\n所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n但是目前我们使用比较多的是 vim 编辑器。\nvim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\n相关文章：史上最全Vim快捷键键位图 — 入门到进阶\n 什么是 vim？ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\nvim 键盘图：\n vi/vim 的使用 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。  若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式 在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式  底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n q 退出程序 w 保存文件  按ESC键可随时退出底线命令模式。\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n vi/vim 使用实例 使用 vi/vim 进入一般模式 如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：\n$ vim runoob.txt\r直接输入 vi 文件名 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！\n按下 i 进入输入模式(也称为编辑模式)，开始编辑文字 在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n按下 ESC 按钮回到一般模式 好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n在一般模式中按下 :wq 储存后离开 vi OK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！\nOK! 这样我们就成功创建了一个 runoob.txt 的文件。\n vi/vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等    移动光标的方法      h 或 向左箭头键(←) 光标向左移动一个字符   j 或 向下箭头键(↓) 光标向下移动一个字符   k 或 向上箭头键(↑) 光标向上移动一个字符   l 或 向右箭头键(→) 光标向右移动一个字符   如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 \u0026ldquo;30j\u0026rdquo; 或 \u0026ldquo;30↓\u0026rdquo; 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！    [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)   [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)   [Ctrl] + [d] 屏幕『向下』移动半页   [Ctrl] + [u] 屏幕『向上』移动半页   + 光标移动到非空格符的下一行   - 光标移动到非空格符的上一行   n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20则光标会向后面移动 20 个字符距离。   0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用)   $ 或功能键[End] 移动到这一行的最后面字符处(常用)   H 光标移动到这个屏幕的最上方那一行的第一个字符   M 光标移动到这个屏幕的中央那一行的第一个字符   L 光标移动到这个屏幕的最下方那一行的第一个字符   G 移动到这个档案的最后一行(常用)   nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)   gg 移动到这个档案的第一行，相当于 1G 啊！ (常用)   n n 为数字。光标向下移动 n 行(常用)   搜索替换    /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)   ?word 向光标之上寻找一个字符串名称为 word 的字符串。   n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！   N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。   使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！    :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)   :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)   :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)   删除、复制与贴上    x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)   nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。   dd 删除游标所在的那一整行(常用)   ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)   d1G 删除光标所在到第一行的所有数据   dG 删除光标所在到最后一行的所有数据   d$ 删除游标所在处，到该行的最后一个字符   d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符   yy 复制游标所在的那一行(常用)   nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)   y1G 复制游标所在行到第一行的所有数据   yG 复制游标所在行到最后一行的所有数据   y0 复制光标所在的那个字符到该行行首的所有数据   y$ 复制光标所在的那个字符到该行行尾的所有数据   p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)   J 将光标所在行与下一行的数据结合成同一行   c 重复删除多个数据，例如向下删除 10 行，[ 10cj ]   u 复原前一个动作。(常用)   [Ctrl]+r 重做上一个动作。(常用)   这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！    . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)    第二部分：一般模式切换到编辑模式的可用的按钮说明    进入输入或取代的编辑模式      i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)   a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)   o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)   r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)   上面这些按键中，在 vi 画面的左下角处会出现『\u0026ndash;INSERT\u0026ndash;』或『\u0026ndash;REPLACE\u0026ndash;』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！    [Esc] 退出编辑模式，回到一般模式中(常用)    第三部分：一般模式切换到指令行模式的可用的按钮说明    指令行的储存、离开等指令      :w 将编辑的数据写入硬盘档案中(常用)   :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！   :q 离开 vi (常用)   :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。   注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～    :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)   ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！   :w [filename] 将编辑的数据储存成另一个档案（类似另存新档）   :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面   :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。   :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！   vim 环境的变更    :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号   :set nonu 与 set nu 相反，为取消行号！    特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。\n举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8cb3d55f266034d95c9dfa3fd34bd968","permalink":"https://academia-hugo.netlify.com/notes/linux-study/vim%E7%AC%94%E8%AE%B0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/linux-study/vim%E7%AC%94%E8%AE%B0/","section":"notes","summary":"Linux vi/vim 转载：https://www.runoob.com/linux/linux-vim.html\n所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n但是目前我们使用比较多的是 vim 编辑器。\nvim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\n相关文章：史上最全Vim快捷键键位图 — 入门到进阶\n 什么是 vim？ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\nvim 键盘图：\n vi/vim 的使用 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。  若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式 在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式  底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":"centos 6.10 安装 docker 官方文档 ：https://docs.docker.com/engine/install/centos/\n查看centos系统版本,6和7有不同的安装步骤\ncat /etc/redhat-release 卸载旧版本 较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。\nyum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 安装 网上试试很多方法都失败了，下面这个亲测可用\nwget https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpm sudo rpm -ivh docker-engine-1.7.1-1.el6.x86_64.rpm ### 安装配置cgroup yum install -y libcgroup sudo vim /etc/fstab 增加一行\nnone /sys/fs/cgroup cgroup defaults 0 0 重启 reboot 启动服务 service docker start 测试 docker -v CentOS Linux release 7.2.1511 安装 docker /docker要求内核版本必须高于3.10，因此先查看自己的内核版本 查看内核\nuname -r yum -y install docker-io yum list installed |grep docker 启动docker服务\nsystemctl start docker.service systemctl status docker.service 开机自启动： 检查服务是否开机启动\nsystemctl is-enabled docker.service 将服务配置成开机启动\nsystemctl enable docker.service 启动服务\nsystemctl start docker.service systemctl 相关其他命令： 禁止开机启动\nsystemctl disable docker.service 停止\nsystemctl stop docker.service 重启\nsystemctl restart docker.service 重启 ","date":1592262000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592262000,"objectID":"7d71515b487f7bf3e99c1987a3925646","permalink":"https://academia-hugo.netlify.com/notes/docker-study/docker%E5%AE%89%E8%A3%85/","publishdate":"2020-06-16T00:00:00+01:00","relpermalink":"/notes/docker-study/docker%E5%AE%89%E8%A3%85/","section":"notes","summary":"centos 6.10 安装 docker 官方文档 ：https://docs.docker.com/engine/install/centos/\n查看centos系统版本,6和7有不同的安装步骤\ncat /etc/redhat-release 卸载旧版本 较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。\nyum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 安装 网上试试很多方法都失败了，下面这个亲测可用\nwget https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpm sudo rpm -ivh docker-engine-1.7.1-1.el6.x86_64.rpm ### 安装配置cgroup yum install -y libcgroup sudo vim /etc/fstab 增加一行\nnone /sys/fs/cgroup cgroup defaults 0 0 重启 reboot 启动服务 service docker start 测试 docker -v CentOS Linux release 7.","tags":null,"title":"docker安装","type":"docs"},{"authors":null,"categories":null,"content":"启动node-exporter docker run -d -p 9100:9100 \\\r-v \u0026quot;/proc:/host/proc:ro\u0026quot; \\\r-v \u0026quot;/sys:/host/sys:ro\u0026quot; \\\r-v \u0026quot;/:/rootfs:ro\u0026quot; \\\r--net=\u0026quot;host\u0026quot; \\\rprom/node-exporter\r等待几秒钟，查看端口是否起来了\nroot@ubuntu:~# netstat -anpt\rActive Internet connections (servers and established)\rProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name\rtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1147/sshd tcp 0 36 192.168.91.132:22 192.168.91.1:63648 ESTABLISHED 2969/0 tcp 0 0 192.168.91.132:22 192.168.91.1:63340 ESTABLISHED 1321/1 tcp6 0 0 :::9100 :::* LISTEN 3070/node_exporter\r访问url：\nhttp://192.168.91.132:9100/metrics\r效果如下：\n这些都是收集到数据，有了它就可以做数据展示了\n启动prometheus 新建目录prometheus，编辑配置文件prometheus.yml\nmkdir /opt/prometheus\rcd /opt/prometheus/\rvim prometheus.yml\r内容如下：\nglobal:\rscrape_interval: 60s\revaluation_interval: 60s\rscrape_configs:\r- job_name: prometheus\rstatic_configs:\r- targets: ['localhost:9090']\rlabels:\rinstance: prometheus\r- job_name: linux\rstatic_configs:\r- targets: ['192.168.91.132:9100']\rlabels:\rinstance: localhost\r注意：修改IP地址，这里的192.168.91.132就是本机地址\n启动prometheus\ndocker run -d \\\r-p 9090:9090 \\\r-v /opt/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \\\rprom/prometheus\r等待几秒钟，查看端口状态\nroot@ubuntu:/opt/prometheus# netstat -anpt\rActive Internet connections (servers and established)\rProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name\rtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1147/sshd tcp 0 36 192.168.91.132:22 192.168.91.1:63648 ESTABLISHED 2969/0 tcp 0 0 192.168.91.132:22 192.168.91.1:63340 ESTABLISHED 1321/1 tcp6 0 0 :::9100 :::* LISTEN 3070/node_exporter\rtcp6 0 0 :::22 :::* LISTEN 1147/sshd tcp6 0 0 :::9090 :::* LISTEN 3336/docker-proxy\r访问url：\nhttp://192.168.91.132:9090/graph\r启动grafana https://grafana.com/grafana/download?platform=linux\n systemctl start grafana-server\rdocker\n新建空文件夹grafana-storage，用来存储数据\nmkdir /opt/grafana-storage\r设置权限\nchmod 777 -R /opt/grafana-storage\r因为grafana用户会在这个目录写入文件，直接设置777，比较简单粗暴！\n启动grafana\ndocker run -d \\\r-p 3000:3000 \\\r--name=grafana \\\r-v /opt/grafana:/var/lib/grafana \\\rgrafana/grafana:5.3.4\rdocker安装mysql_exporter  下载mysql_exporter镜像  docker pull prom/mysqld-exporter\r  mysql_exporter需要链接数据库，mysql创建mysql_monitor用户，添加PROCESS, REPLICATION CLIENT权限\n  mysql_exporter需要链接数据库，mysql创建mysql_monitor用户，添加PROCESS, REPLICATION CLIENT权限\n  mysql\u0026gt; INSERT INTO mysql.user(Host,User,Password) VALUES(\u0026#34;localhost\u0026#34;, \u0026#34;mysql_monitor\u0026#34;, password(\u0026#34;mysql_monitor\u0026#34;)); mysql\u0026gt; GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO \u0026#39;mysql_monitor\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;mysql_monitor\u0026#39;; mysql\u0026gt; GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO \u0026#39;mysql_monitor\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;mysql_monitor\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES;  docker启动mysql_exporter镜像  docker run -d -p 9104:9104 \\  --name=mysqld-exporter \\  --restart=always \\  -e DATA_SOURCE_NAME=\u0026#34;mysql_monitor:mysql_monitor@(172.17.0.1:3306)/\u0026#34; \\  prom/mysqld-exporter  修改prometheus.yml文件  vim prometheus.yml\r添加\n- job_name: mysql\rstatic_configs:\r- targets: ['203.176.95.155:9104']\r","date":1592262000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592262000,"objectID":"be336c87897f8fc75617136633a75933","permalink":"https://academia-hugo.netlify.com/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E5%AE%89%E8%A3%85/","publishdate":"2020-06-16T00:00:00+01:00","relpermalink":"/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E5%AE%89%E8%A3%85/","section":"notes","summary":"启动node-exporter docker run -d -p 9100:9100 \\\r-v \u0026quot;/proc:/host/proc:ro\u0026quot; \\\r-v \u0026quot;/sys:/host/sys:ro\u0026quot; \\\r-v \u0026quot;/:/rootfs:ro\u0026quot; \\\r--net=\u0026quot;host\u0026quot; \\\rprom/node-exporter\r等待几秒钟，查看端口是否起来了\nroot@ubuntu:~# netstat -anpt\rActive Internet connections (servers and established)\rProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name\rtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1147/sshd tcp 0 36 192.168.91.132:22 192.168.91.1:63648 ESTABLISHED 2969/0 tcp 0 0 192.168.91.132:22 192.168.91.1:63340 ESTABLISHED 1321/1 tcp6 0 0 :::9100 :::* LISTEN 3070/node_exporter\r访问url：\nhttp://192.168.91.132:9100/metrics\r效果如下：","tags":null,"title":"普罗米修斯安装","type":"docs"},{"authors":null,"categories":null,"content":"开放端口 开放8080端口\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --reload 关闭8080端口\nfirewall-cmd --zone=public --remove-port=8080/tcp --permanent 查看防火墙所有开放的端口 firewall-cmd --zone=public --list-ports 查看防火墙状态 firewall-cmd --state 查看监听的端口 netstat -lnpt 查看进程端口占用 netstat -lnpt |grep 8081\r​```shell\r![](/img/linux/18.jpg)\r## 查看进程详情\r​```shell\rps 8081\r中止进程 kill -9 8081 查看防火墙状态 systemctl status firewalld service iptables status 暂时关闭防火墙 systemctl stop firewalld service iptables stop 永久关闭防火墙 systemctl disable firewalld chkconfig iptables off 重启防火墙 systemctl enable firewalld service iptables restart 永久关闭后重启 chkconfig iptables on ","date":1592262000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592262000,"objectID":"6b674402ec166c5d71c54d9db85b1766","permalink":"https://academia-hugo.netlify.com/notes/linux-study/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/","publishdate":"2020-06-16T00:00:00+01:00","relpermalink":"/notes/linux-study/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/","section":"notes","summary":"开放端口 开放8080端口\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --reload 关闭8080端口\nfirewall-cmd --zone=public --remove-port=8080/tcp --permanent 查看防火墙所有开放的端口 firewall-cmd --zone=public --list-ports 查看防火墙状态 firewall-cmd --state 查看监听的端口 netstat -lnpt 查看进程端口占用 netstat -lnpt |grep 8081\r​```shell\r![](/img/linux/18.jpg)\r## 查看进程详情\r​```shell\rps 8081\r中止进程 kill -9 8081 查看防火墙状态 systemctl status firewalld service iptables status 暂时关闭防火墙 systemctl stop firewalld service iptables stop 永久关闭防火墙 systemctl disable firewalld chkconfig iptables off 重启防火墙 systemctl enable firewalld service iptables restart 永久关闭后重启 chkconfig iptables on ","tags":null,"title":"防火墙配置","type":"docs"},{"authors":null,"categories":null,"content":"docker hub地址： https://hub.docker.com/\n镜像命令 运行hello-world docker run hello-world 查询镜像 docker images 查看主机上可运行的镜像 docker images -a 列出本地所有镜像 docker images -q 只显示镜像ID docker images --digests 显示镜像摘要信息 搜索镜像 （系统去docker hub搜索，但是是从阿里云拉）\ndocker search XXX 列出点赞数不少于20的tomcat镜像\ndocker search -s 20 tomcat 下载（拉取）镜像 docker pull XXX\n下载tomcat\ndocker pull tomcat 后面接版本号，不写就是最新版本 删除镜像 docker rmi image id (有容器的时候删不掉) 删除全部镜像\ndocker rmi $(docker images -q) 容器命令 运行容器\ndocker run -it XXX 后台运行\ndocker run -d -it XXX 运行hellow-world\ndocker run -it fd74c3615f76 查看 l列出所有正在运行的容器\ndocker ps 查看两条运行记录\ndocker ps -n 2 启动容器 启动容器\ndocker start XXX（容器ID或者容器名） 进入交互模式 docker exec -it XXX /bin/bash 安全退出交互式界面： Ctrl+P+Q 重启容器\ndocker restart XXX（容器ID或者容器名） 关闭容器 温柔停止\ndocker stop XXX（容器ID或者容器名） 强制停止\ndocker stop XXX（容器ID或者容器名） docker kill XXX（容器ID或者容器名） 删除容器 docker rm -f XXX（容器ID或者容器名） 停止所有容器\ndocker stop $(docker ps -aq) 删除所有容器\ndocker rm $(docker ps -aq) 从容器创建一个新的镜像 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。\ndocker commit -a \u0026#34;runoob.com\u0026#34; -m \u0026#34;my apache\u0026#34; a404c6c174a2 mytoncat:v1  **-a :**提交的镜像作者； **-c :**使用Dockerfile指令来创建镜像； **-m :**提交时的说明文字； **-p :**在commit时，将容器暂停。  查看容器占用 ps -ef|grep 容器Id\n[root@wentao-2 order]# ps -ef|grep 3a61cb3fd4f6\rroot 7358 12956 0 09:14 ? 00:00:00 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/3a61cb3fd4f64f6fed464ca6c7185c5138c9256ac8ceb049b9527272573e994d -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc\rroot 7893 5652 0 09:19 pts/0 00:00:00 grep --color=auto 3a61cb3fd4f6\r123\rtop -p 7358(pid)\n[root@wentao-2 order]# top -p 7358\rtop - 09:22:14 up 103 days, 18:13, 2 users, load average: 0.04, 0.09, 0.12\rTasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie\r%Cpu(s): 0.8 us, 0.3 sy, 0.0 ni, 98.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st\rKiB Mem : 8010424 total, 170620 free, 7303264 used, 536540 buff/cache\rKiB Swap: 0 total, 0 free, 0 used. 369860 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 7358 root 20 0 10724 3744 2656 S 0.0 0.0 0:00.05 containerd-shim 123456789\r参数说明： PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行 NInice：值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"d5c9c217ede87fd22b2a60e8b2fdf7ad","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dock%E5%91%BD%E4%BB%A4/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/notes/docker-study/dock%E5%91%BD%E4%BB%A4/","section":"notes","summary":"docker hub地址： https://hub.docker.com/\n镜像命令 运行hello-world docker run hello-world 查询镜像 docker images 查看主机上可运行的镜像 docker images -a 列出本地所有镜像 docker images -q 只显示镜像ID docker images --digests 显示镜像摘要信息 搜索镜像 （系统去docker hub搜索，但是是从阿里云拉）\ndocker search XXX 列出点赞数不少于20的tomcat镜像\ndocker search -s 20 tomcat 下载（拉取）镜像 docker pull XXX\n下载tomcat\ndocker pull tomcat 后面接版本号，不写就是最新版本 删除镜像 docker rmi image id (有容器的时候删不掉) 删除全部镜像\ndocker rmi $(docker images -q) 容器命令 运行容器\ndocker run -it XXX 后台运行\ndocker run -d -it XXX 运行hellow-world","tags":null,"title":"docker命令","type":"docs"},{"authors":null,"categories":null,"content":"安装MySQL 卸载老版本MySQL 检查是否已经安装过mysql\nrpm -qa | grep mysql 强制卸载\nrpm -e --nodeps mysql-libs-5.1.73-8.el6_8.x86_64 安装编译代码需要的包 复制mysql-5.6.14.tar.gz到Linux服务器上 安装gcc环境\nyum -y install make gcc-c++ cmake bison-devel ncurses-devel tar -xzvf mysql-5.6.14.tar.gz 源码编译\ncd mysql-5.6.14 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci 编译并安装\nmake \u0026amp;\u0026amp; make install 添加mysql用户和分组 cat /etc/passwd 查看用户列表 cat /etc/group 查看用户组列表 groupadd mysql useradd -g mysql mysql 修改/usr/local/mysql权限\nchown -R mysql:mysql /usr/local/mysql 初始化配置， 进入安装路径（在执行下面的指令），执行初始化配置脚本，创建系统自带的数据库和表\ncd /usr/local/mysql scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql  注：在启动MySQL服务时，会按照一定次序搜索my.cnf，先在/etc目录下找，找不到则会搜索\u0026quot;$basedir/my.cnf\u0026rdquo;，在本例中就是 /usr/local/mysql/my.cnf，这是新版MySQL的配置文件的默认位置！\n注意：在CentOS 6.8版操作系统的最小安装完成后，在/etc目录下会存在一个my.cnf，需要将此文件更名为其他的名字，如：/etc/my.cnf.bak，否则，该文件会干扰源码安装的MySQL的正确配置，造成无法启动。\n 修改名称，防止干扰：\nmv /etc/my.cnf /etc/my.cnf.bak 启动MySQL 添加服务，拷贝服务脚本到init.d目录，并设置开机启动\n[注意在 /usr/local/mysql 下执行]\ncp support-files/mysql.server /etc/init.d/mysql 设置默认自启\nchkconfig mysql on service mysql start --启动MySQL 修改密码 cd /usr/local/mysql/bin ./mysql -u 账号 -p 密码 SET PASSWORD = PASSWORD(\u0026#39;你的新密码\u0026#39;); quit 退出Mysql 给linux下的mysql用户开启远程登录权限 配好之后发现本地用Navicat连不上,原因是没有开启远程登录权限\nmysql\u0026gt; GRANT ALL PRIVILEGES ON ① TO \u0026lsquo;②\u0026rsquo;@\u0026lsquo;③\u0026rsquo; IDENTIFIED BY \u0026lsquo;④\u0026rsquo; ;\n① ：允许访问的数据库,可以是某个数据库，也可以是*.*所有\n②：分配的账号\n③：允许访问的主机IP，也可以是%所有IP\n④：分配的密码\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"cc34fa332d96e0e11c2e59eb98ddfe73","permalink":"https://academia-hugo.netlify.com/notes/linux-study/%E5%AE%89%E8%A3%85mysql/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/notes/linux-study/%E5%AE%89%E8%A3%85mysql/","section":"notes","summary":"安装MySQL 卸载老版本MySQL 检查是否已经安装过mysql\nrpm -qa | grep mysql 强制卸载\nrpm -e --nodeps mysql-libs-5.1.73-8.el6_8.x86_64 安装编译代码需要的包 复制mysql-5.6.14.tar.gz到Linux服务器上 安装gcc环境\nyum -y install make gcc-c++ cmake bison-devel ncurses-devel tar -xzvf mysql-5.6.14.tar.gz 源码编译\ncd mysql-5.6.14 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci 编译并安装\nmake \u0026amp;\u0026amp; make install 添加mysql用户和分组 cat /etc/passwd 查看用户列表 cat /etc/group 查看用户组列表 groupadd mysql useradd -g mysql mysql 修改/usr/local/mysql权限\nchown -R mysql:mysql /usr/local/mysql 初始化配置， 进入安装路径（在执行下面的指令），执行初始化配置脚本，创建系统自带的数据库和表","tags":null,"title":"","type":"docs"},{"authors":null,"categories":null,"content":"官网https://newuser.aiops.com/ ","date":1598310000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598310000,"objectID":"acb765029b83343daa7e0193577ddf62","permalink":"https://academia-hugo.netlify.com/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/","publishdate":"2020-08-25T00:00:00+01:00","relpermalink":"/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/","section":"notes","summary":"官网https://newuser.aiops.com/ ","tags":null,"title":"普罗米修斯监控告警","type":"docs"},{"authors":null,"categories":null,"content":"介绍 Eric Zhao edited this page on 11 Jun · 121 revisions\nSentinel: 分布式系统的流量防卫兵 Sentinel 是什么？ 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nSentinel 具有以下特征:\n 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。  Sentinel 的主要特性：\nSentinel 的开源生态：\nSentinel 分为两个部分:\n 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。  Quick Start 1.1 公网 Demo 如果希望最快的了解 Sentinel 在做什么，我们可以通过 Sentinel 新手指南 来运行一个例子，并且能在云上控制台上看到最直观的监控和流控效果等。\n1.2 手动接入 Sentinel 以及控制台 下面的例子将展示应用如何三步接入 Sentinel。同时，Sentinel 也提供所见即所得的控制台，可以实时监控资源以及管理规则。\nSTEP 1. 在应用中引入Sentinel Jar包 如果应用使用 pom 工程，则在 pom.xml 文件中加入以下代码即可：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;sentinel-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.7.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 注意: 从 Sentinel 1.5.0 开始仅支持 JDK 1.7 或者以上版本。Sentinel 1.5.0 之前的版本最低支持 JDK 1.6。\n 如果您未使用依赖管理工具，请到 Maven Center Repository 直接下载 JAR 包。\nSTEP 2. 定义资源 接下来，我们把需要控制流量的代码用 Sentinel API SphU.entry(\u0026quot;HelloWorld\u0026quot;) 和 entry.exit() 包围起来即可。在下面的例子中，我们将 System.out.println(\u0026quot;hello world\u0026quot;); 这端代码作为资源，用 API 包围起来（埋点）。参考代码如下:\npublic static void main(String[] args) {\rinitFlowRules();\rwhile (true) {\rEntry entry = null;\rtry {\rentry = SphU.entry(\u0026quot;HelloWorld\u0026quot;);\r/*您的业务逻辑 - 开始*/\rSystem.out.println(\u0026quot;hello world\u0026quot;);\r/*您的业务逻辑 - 结束*/\r} catch (BlockException e1) {\r/*流控逻辑处理 - 开始*/\rSystem.out.println(\u0026quot;block!\u0026quot;);\r/*流控逻辑处理 - 结束*/\r} finally {\rif (entry != null) {\rentry.exit();\r}\r}\r}\r}\r完成以上两步后，代码端的改造就完成了。当然，我们也提供了 注解支持模块，可以以低侵入性的方式定义资源。\nSTEP 3. 定义规则 接下来，通过规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。\nprivate static void initFlowRules(){\rList\u0026lt;FlowRule\u0026gt; rules = new ArrayList\u0026lt;\u0026gt;();\rFlowRule rule = new FlowRule();\rrule.setResource(\u0026quot;HelloWorld\u0026quot;);\rrule.setGrade(RuleConstant.FLOW_GRADE_QPS);\r// Set limit QPS to 20.\rrule.setCount(20);\rrules.add(rule);\rFlowRuleManager.loadRules(rules);\r}\r完成上面 3 步，Sentinel 就能够正常工作了。更多的信息可以参考 使用文档。\nSTEP 4. 检查效果 Demo 运行之后，我们可以在日志 ~/logs/csp/${appName}-metrics.log.xxx 里看到下面的输出:\n|--timestamp-|------date time----|-resource-|p |block|s |e|rt\r1529998904000|2018-06-26 15:41:44|HelloWorld|20|0 |20|0|0\r1529998905000|2018-06-26 15:41:45|HelloWorld|20|5579 |20|0|728\r1529998906000|2018-06-26 15:41:46|HelloWorld|20|15698|20|0|0\r1529998907000|2018-06-26 15:41:47|HelloWorld|20|19262|20|0|0\r1529998908000|2018-06-26 15:41:48|HelloWorld|20|19502|20|0|0\r1529998909000|2018-06-26 15:41:49|HelloWorld|20|18386|20|0|0\r其中 p 代表通过的请求, block 代表被阻止的请求, s 代表成功执行完成的请求个数, e 代表用户自定义的异常, rt 代表平均响应时长。\n可以看到，这个程序每秒稳定输出 \u0026ldquo;hello world\u0026rdquo; 20 次，和规则中预先设定的阈值是一样的。\n更详细的说明可以参考: 如何使用\n更多的例子可以参考: Sentinel Examples\nSTEP 5. 启动 Sentinel 控制台 您可以参考 Sentinel 控制台文档 启动控制台，可以实时监控各个资源的运行情况，并且可以实时地修改限流规则。\n详细文档 请移步 Wiki，查阅详细的文档、示例以及使用说明。若您希望从其它熔断降级组件（如 Hystrix）迁移或进行功能对比，可以参考 迁移指南。\nPlease refer to README for README in English。\n与 Sentinel 相关的生态（包括社区用户实现的扩展、整合、示例以及文章）可以参见 Awesome Sentinel，欢迎补充！\n如果您正在使用 Sentinel，欢迎在 Wanted: Who is using Sentinel 留言告诉我们您的使用场景，以便我们更好地去改进。\n","date":1597622400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597622400,"objectID":"9962dd871bd25c58104f5490abeb7afd","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel/","publishdate":"2020-08-17T00:00:00Z","relpermalink":"/notes/cloud-albaba/sentinel/","section":"notes","summary":"介绍 Eric Zhao edited this page on 11 Jun · 121 revisions\nSentinel: 分布式系统的流量防卫兵 Sentinel 是什么？ 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nSentinel 具有以下特征:\n 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。  Sentinel 的主要特性：\nSentinel 的开源生态：\nSentinel 分为两个部分:\n 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。  Quick Start 1.1 公网 Demo 如果希望最快的了解 Sentinel 在做什么，我们可以通过 Sentinel 新手指南 来运行一个例子，并且能在云上控制台上看到最直观的监控和流控效果等。","tags":null,"title":"sentinel","type":"docs"},{"authors":null,"categories":null,"content":"新建项目 cloudalibaba-config-nacos-client3377\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 公式 ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} 添加配置 yml bootstrap.yml\nserver:\rport: 3377\rspring:\rapplication:\rname: nacos-config-client\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848 config:\rserver-addr: localhost:8848 file-extension: yml application.yml\nspring:\rprofiles:\ractive: dev controller package com.nacos.config.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; /** * * @author yzg * @version 1.0 * @create 2020/08/17 */ @RestController @RefreshScope // 支持nacos的动态刷新 public class ConfigClientController { @Value(\u0026#34;${config.info}\u0026#34;) private String configInfo; @GetMapping(\u0026#34;/config/info\u0026#34;) public String getConfigInfo(){ return configInfo; } } 启动类 package com.nacos.config; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class NacosConfigCilent3377 { public static void main(String[] args) { SpringApplication.run(NacosConfigCilent3377.class, args); } } 测试 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"9ada84be7af67e85af05c5548a4e7cb5","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","section":"notes","summary":"新建项目 cloudalibaba-config-nacos-client3377\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 公式 ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} 添加配置 yml bootstrap.yml\nserver:\rport: 3377\rspring:\rapplication:\rname: nacos-config-client\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848 config:\rserver-addr: localhost:8848 file-extension: yml application.yml\nspring:\rprofiles:\ractive: dev controller package com.nacos.config.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; /** * * @author yzg * @version 1.0 * @create 2020/08/17 */ @RestController @RefreshScope // 支持nacos的动态刷新 public class ConfigClientController { @Value(\u0026#34;${config.info}\u0026#34;) private String configInfo; @GetMapping(\u0026#34;/config/info\u0026#34;) public String getConfigInfo(){ return configInfo; } } 启动类 package com.","tags":null,"title":"Nacos配置中心","type":"docs"},{"authors":null,"categories":null,"content":"按资源名称限流 @GetMapping(\u0026#34;/byResource\u0026#34;) @SentinelResource(value = \u0026#34;byResource\u0026#34;, blockHandler = \u0026#34;handleException\u0026#34;) public CommomResult byResource(){ return new CommomResult(200, \u0026#34;按资源名称限流测试OK\u0026#34;, new Payment(2020L, \u0026#34;serial001\u0026#34;)); } public CommomResult handleException(BlockException blockException){ return new CommomResult\u0026lt;\u0026gt;(444, blockException.getClass().getCanonicalName()+\u0026#34;\\t服务不可用\u0026#34; ); } 测试 配置1\n配置2\n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"1b7b48b785e57252c46be26f95031c62","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinelresource/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinelresource/","section":"notes","summary":"按资源名称限流 @GetMapping(\u0026#34;/byResource\u0026#34;) @SentinelResource(value = \u0026#34;byResource\u0026#34;, blockHandler = \u0026#34;handleException\u0026#34;) public CommomResult byResource(){ return new CommomResult(200, \u0026#34;按资源名称限流测试OK\u0026#34;, new Payment(2020L, \u0026#34;serial001\u0026#34;)); } public CommomResult handleException(BlockException blockException){ return new CommomResult\u0026lt;\u0026gt;(444, blockException.getClass().getCanonicalName()+\u0026#34;\\t服务不可用\u0026#34; ); } 测试 配置1\n配置2","tags":null,"title":"SentinelResource注解","type":"docs"},{"authors":null,"categories":null,"content":"优化代码 blockHandlerClass ：兜底类\nblockHandler：兜底方法\n@GetMapping(\u0026#34;/rateLimit/customerBlockHandler\u0026#34;) @SentinelResource(value = \u0026#34;customerBlockHandler\u0026#34;, blockHandlerClass = CustomerBlockHandler.class, blockHandler = \u0026#34;handlerException2\u0026#34;) public CommomResult customerBlockHandler(){ return new CommomResult(200, \u0026#34;客户自定义 限流测试OK\u0026#34;, new Payment(2020L, \u0026#34;serial001\u0026#34;)); } CustomerBlockHandler.java\npackage com.sentinel.myhandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import cloud.api.common.entities.CommomResult; /** * * @author yzg * @version 1.0 * @create 2020/08/20 */ public class CustomerBlockHandler { public static CommomResult handlerException(BlockException exception) { return new CommomResult(444, \u0026#34;客户自定义，global handlerException---1\u0026#34;); } public static CommomResult handlerException2(BlockException exception) { return new CommomResult(444, \u0026#34;客户自定义，global handlerException---2\u0026#34;); } } 配置 测试 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"6f16539fce5e94f5e051422ad455e299","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinelresource%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinelresource%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6/","section":"notes","summary":"优化代码 blockHandlerClass ：兜底类\nblockHandler：兜底方法\n@GetMapping(\u0026#34;/rateLimit/customerBlockHandler\u0026#34;) @SentinelResource(value = \u0026#34;customerBlockHandler\u0026#34;, blockHandlerClass = CustomerBlockHandler.class, blockHandler = \u0026#34;handlerException2\u0026#34;) public CommomResult customerBlockHandler(){ return new CommomResult(200, \u0026#34;客户自定义 限流测试OK\u0026#34;, new Payment(2020L, \u0026#34;serial001\u0026#34;)); } CustomerBlockHandler.java\npackage com.sentinel.myhandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import cloud.api.common.entities.CommomResult; /** * * @author yzg * @version 1.0 * @create 2020/08/20 */ public class CustomerBlockHandler { public static CommomResult handlerException(BlockException exception) { return new CommomResult(444, \u0026#34;客户自定义，global handlerException---1\u0026#34;); } public static CommomResult handlerException2(BlockException exception) { return new CommomResult(444, \u0026#34;客户自定义，global handlerException---2\u0026#34;); } } 配置 测试 ","tags":null,"title":"SentinelResource注解代码解耦","type":"docs"},{"authors":null,"categories":null,"content":"下载jar https://github.com/alibaba/Sentinel/releases/tag/1.7.2\n运行 java -Dserver.port=:8858 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar\r测试访问 直接访问 http://127.0.0.1:8858\n使用账号：sentinel，密码：sentinel 登录\n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"093fa96944d8ea1a1480a881047a43cd","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E5%AE%89%E8%A3%85/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E5%AE%89%E8%A3%85/","section":"notes","summary":"下载jar https://github.com/alibaba/Sentinel/releases/tag/1.7.2\n运行 java -Dserver.port=:8858 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar\r测试访问 直接访问 http://127.0.0.1:8858\n使用账号：sentinel，密码：sentinel 登录","tags":null,"title":"sentinel安装","type":"docs"},{"authors":null,"categories":null,"content":"官网教程地址：https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel\n改造项目 cloudalibaba-sentinel-service8401\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sentinel-datasource-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml  sentinel:\rtransport:\r# sentinel dashboard 地址\rdashboard: 192.168.126.128:8858\r# 默认为8719，如果被占用会自动+1，直到找到为止\rport: 8719\r# 流控规则持久化到nacos\rdatasource:\rdsl:\rnacos:\rserver-addr: 192.168.126.128:88488\rdata-id: ${spring.application.name}\rgroup-id: DEFAULT_GROUP\rdata-type: json\rrule-type: flow\r配置 [ { \u0026#34;resource\u0026#34;: \u0026#34;/testA\u0026#34;, \u0026#34;count\u0026#34;: 1, \u0026#34;grade\u0026#34;: 1, \u0026#34;limitApp\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;strategy\u0026#34;: 0, \u0026#34;controlBehavior\u0026#34;: 0 } ] resource : 资源名称\nlimitApp：来源应用\ngrade：阈值类型，0表示线程数，1表示QPS\ncount : 单机阈值 strategy：流控模式，0直接，1关联，2链路 controlBehavior：流控效果，0快速失败，1warm up .2排队等待 clusterMode:是否集群\n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"77c82b59f8c19e090e85607b8ebd1939","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE/","section":"notes","summary":"官网教程地址：https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel\n改造项目 cloudalibaba-sentinel-service8401\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sentinel-datasource-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml  sentinel:\rtransport:\r# sentinel dashboard 地址\rdashboard: 192.168.126.128:8858\r# 默认为8719，如果被占用会自动+1，直到找到为止\rport: 8719\r# 流控规则持久化到nacos\rdatasource:\rdsl:\rnacos:\rserver-addr: 192.168.126.128:88488\rdata-id: ${spring.application.name}\rgroup-id: DEFAULT_GROUP\rdata-type: json\rrule-type: flow\r配置 [ { \u0026#34;resource\u0026#34;: \u0026#34;/testA\u0026#34;, \u0026#34;count\u0026#34;: 1, \u0026#34;grade\u0026#34;: 1, \u0026#34;limitApp\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;strategy\u0026#34;: 0, \u0026#34;controlBehavior\u0026#34;: 0 } ] resource : 资源名称\nlimitApp：来源应用\ngrade：阈值类型，0表示线程数，1表示QPS\ncount : 单机阈值 strategy：流控模式，0直接，1关联，2链路 controlBehavior：流控效果，0快速失败，1warm up .2排队等待 clusterMode:是否集群","tags":null,"title":"sentinel持久化配置","type":"docs"},{"authors":null,"categories":null,"content":"架构 提供者\ncloudalibaba-provider-payment9003\ncloudalibaba-provider-payment9004\n消费者\ncloudalibaba-consumer-nacos-order8004 \n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"90870ca3a5ed354ebfd13529770736e8","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%95%B4%E5%90%88nacos+openfegin/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%95%B4%E5%90%88nacos+openfegin/","section":"notes","summary":"架构 提供者\ncloudalibaba-provider-payment9003\ncloudalibaba-provider-payment9004\n消费者\ncloudalibaba-consumer-nacos-order8004","tags":null,"title":"sentinel整合nacos+openfegin","type":"docs"},{"authors":null,"categories":null,"content":"新建项目 cloudalibaba-sentinel-service8401\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 8401\rspring:\rapplication:\rname: cloudalibaba-sentinel-service\rcloud:\rnacos:\rdiscovery:\r# Nacos服务注册中心地址\rserver-addr: localhost:8848\rsentinel:\rtransport:\r# sentinel dashboard 地址\rdashboard: localhost:8080\r# 默认为8719，如果被占用会自动+1，直到找到为止\rport: 8719\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot; controller package com.sentinel.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import lombok.extern.slf4j.Slf4j; /** * * @author yzg * @version 1.0 * @create 2020/08/17 */ @RestController @Slf4j public class FlowLimitController { @GetMapping(\u0026#34;/testA\u0026#34;) public String testA(){ return \u0026#34;testA-----\u0026#34;; } @GetMapping(\u0026#34;/testB\u0026#34;) public String testB(){ return \u0026#34;testB -----\u0026#34;; } } 启动类 package com.sentinel; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; /** * @author yzg */ @SpringBootApplication @EnableDiscoveryClient public class MainApp8401 { public static void main(String[] args) { SpringApplication.run(MainApp8401.class, args); } } 测试 访问http://localhost:8401//testA\nsentinel是懒加载，服务需要访问一次才能被sentinel监控 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"49d7b5061db7ba81017c2b8043f1eb75","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/","section":"notes","summary":"新建项目 cloudalibaba-sentinel-service8401\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 8401\rspring:\rapplication:\rname: cloudalibaba-sentinel-service\rcloud:\rnacos:\rdiscovery:\r# Nacos服务注册中心地址\rserver-addr: localhost:8848\rsentinel:\rtransport:\r# sentinel dashboard 地址\rdashboard: localhost:8080\r# 默认为8719，如果被占用会自动+1，直到找到为止\rport: 8719\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot; controller package com.sentinel.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import lombok.extern.slf4j.Slf4j; /** * * @author yzg * @version 1.0 * @create 2020/08/17 */ @RestController @Slf4j public class FlowLimitController { @GetMapping(\u0026#34;/testA\u0026#34;) public String testA(){ return \u0026#34;testA-----\u0026#34;; } @GetMapping(\u0026#34;/testB\u0026#34;) public String testB(){ return \u0026#34;testB -----\u0026#34;; } } 启动类 package com.","tags":null,"title":"sentinel服务监控","type":"docs"},{"authors":null,"categories":null,"content":"官网 https://github.com/alibaba/Sentinel/wiki/Flow-Control#flow-control-by-threadqps\n新增流控规则 测试 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"3abce11a5b062c1e08d15af0627b90a8","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-qps%E7%9B%B4%E6%8E%A5%E5%A4%B1%E8%B4%A5/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-qps%E7%9B%B4%E6%8E%A5%E5%A4%B1%E8%B4%A5/","section":"notes","summary":"官网 https://github.com/alibaba/Sentinel/wiki/Flow-Control#flow-control-by-threadqps\n新增流控规则 测试 ","tags":null,"title":"sentinel流控-QPS直接失败","type":"docs"},{"authors":null,"categories":null,"content":"官网 https://github.com/alibaba/Sentinel/wiki/Flow-Control#flow-control-by-threadqps\nQPS和线程 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"9ad73063f299667d757923b1f35fa9c4","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-%E7%BA%BF%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%A4%B1%E8%B4%A5/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-%E7%BA%BF%E7%A8%8B%E7%9B%B4%E6%8E%A5%E5%A4%B1%E8%B4%A5/","section":"notes","summary":"官网 https://github.com/alibaba/Sentinel/wiki/Flow-Control#flow-control-by-threadqps\nQPS和线程 ","tags":null,"title":"sentinel流控-线程直接失败","type":"docs"},{"authors":null,"categories":null,"content":"官网 [https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81\u0026mdash;%E5%86%B7%E5%90%AF%E5%8A%A8](https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8\n预热 预热（RuleConstant.CONTROL_BEHAVIOR_WARM_UP） 如果系统的使用率一段时间以来一直很低，但是突然有大量请求进入，则系统可能无法立即处理 所 有这些请求。但是，如果我们稳步增加传入的请求并允许系统预热，则它最终可能能够处理所 有请求\n默认 coldFactor 为 3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值\n配置 测试 初始化阈值为10 / 3 = 3 , QPS 阈值 进过`5``秒后逐渐升至10\n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"afcec9f8bb9e9764ac5305d7b002d5ee","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-%E9%A2%84%E7%83%AD/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E6%B5%81%E6%8E%A7-%E9%A2%84%E7%83%AD/","section":"notes","summary":"官网 [https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81\u0026mdash;%E5%86%B7%E5%90%AF%E5%8A%A8](https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8\n预热 预热（RuleConstant.CONTROL_BEHAVIOR_WARM_UP） 如果系统的使用率一段时间以来一直很低，但是突然有大量请求进入，则系统可能无法立即处理 所 有这些请求。但是，如果我们稳步增加传入的请求并允许系统预热，则它最终可能能够处理所 有请求\n默认 coldFactor 为 3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值\n配置 测试 初始化阈值为10 / 3 = 3 , QPS 阈值 进过`5``秒后逐渐升至10","tags":null,"title":"sentinel流控-预热","type":"docs"},{"authors":null,"categories":null,"content":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81\n","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"8ca9e9dfa9ce3e63407a0b38e93aeea3","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99/","section":"notes","summary":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81","tags":null,"title":"sentinel系统规则","type":"docs"},{"authors":null,"categories":null,"content":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7\nRT模式 配置 一秒钟10个进程（大于5个） 调用testB,我们希望200毫秒处理完本次任务，如果20毫秒没处理完，在未来的3秒时间窗口内，断路器打开\n让服务器响应1秒\n@GetMapping(\u0026#34;/testB\u0026#34;) public String testB(){ try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;testB -----\u0026#34;; } 测试 异常比例 触发条件\n 每秒请求数大于5 .异常比例大于0.2  异常数 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"9d4e8c6ddcf9b5e47a590ea733a9a7b1","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentinel%E9%99%8D%E7%BA%A7/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentinel%E9%99%8D%E7%BA%A7/","section":"notes","summary":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7\nRT模式 配置 一秒钟10个进程（大于5个） 调用testB,我们希望200毫秒处理完本次任务，如果20毫秒没处理完，在未来的3秒时间窗口内，断路器打开\n让服务器响应1秒\n@GetMapping(\u0026#34;/testB\u0026#34;) public String testB(){ try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;testB -----\u0026#34;; } 测试 异常比例 触发条件\n 每秒请求数大于5 .异常比例大于0.2  异常数 ","tags":null,"title":"sentinel降级","type":"docs"},{"authors":null,"categories":null,"content":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81\n配置 //热点限流  @GetMapping(\u0026#34;/testHotKey\u0026#34;) @SentinelResource(value = \u0026#34;testHotKey\u0026#34;, blockHandler = \u0026#34;dealTestHotKey\u0026#34;) public String testHotKey(@RequestParam(value = \u0026#34;p1\u0026#34;, required = false) String p1, @RequestParam(value = \u0026#34;p2\u0026#34;, required = false) String p2){ return \u0026#34;testHotKey -----\u0026#34;; } public String dealTestHotKey(String p1, String p2, BlockException blockException){ return \u0026#34;deal TestHotKey------QAQ-\u0026#34;; } 测试 访问http://localhost:8401/testHotKey\n访问http://localhost:8401/testHotKey?p1=a\n访问http://localhost:8401/testHotKey?p2=a\n访问http://localhost:8401/testHotKey?p2=a\u0026amp;p1=a\n参数例外项 访问http://localhost:8401/testHotKey?p1=5 ","date":1597618800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597618800,"objectID":"0b86af31aea901eb57cf7a8aad396c52","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/sentine%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/","publishdate":"2020-08-17T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/sentine%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/","section":"notes","summary":"官网 :https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81\n配置 //热点限流  @GetMapping(\u0026#34;/testHotKey\u0026#34;) @SentinelResource(value = \u0026#34;testHotKey\u0026#34;, blockHandler = \u0026#34;dealTestHotKey\u0026#34;) public String testHotKey(@RequestParam(value = \u0026#34;p1\u0026#34;, required = false) String p1, @RequestParam(value = \u0026#34;p2\u0026#34;, required = false) String p2){ return \u0026#34;testHotKey -----\u0026#34;; } public String dealTestHotKey(String p1, String p2, BlockException blockException){ return \u0026#34;deal TestHotKey------QAQ-\u0026#34;; } 测试 访问http://localhost:8401/testHotKey\n访问http://localhost:8401/testHotKey?p1=a\n访问http://localhost:8401/testHotKey?p2=a\n访问http://localhost:8401/testHotKey?p2=a\u0026amp;p1=a\n参数例外项 访问http://localhost:8401/testHotKey?p1=5 ","tags":null,"title":"sentine热点参数限流","type":"docs"},{"authors":null,"categories":null,"content":"新建项目 cloudalibaba-consumer-nacos-order8013\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 8013\rspring:\rapplication:\rname: nacos-order-consumer\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848\r#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）\rservice-url:\rnacos-user-service: http://nacos-payment-provider\rConfig nacos自带了负载均衡，所以需要加上@LoadBalanced注解\npackage com.cloud.provider.comsumer.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; /** * * @author yzg * @version 1.0 * @create 2020/08/10 */ @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } } controller package com.cloud.provider.comsumer.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; /** * * @author yzg * @version 1.0 * @create 2020/08/10 */ @RestController @Slf4j public class OrderNacosController { @Resource private RestTemplate restTemplate; @Value(\u0026#34;${service-url.nacos-user-service}\u0026#34;) private String serverUrl; @GetMapping(\u0026#34;/consumer/payment/nacos/{id}\u0026#34;) public String paymentInfo(@PathVariable(\u0026#34;id\u0026#34;) Integer id){ return restTemplate.getForObject(serverUrl + \u0026#34;/payment/nacos/\u0026#34; + id, String.class); } } 启动类 package com.cloud.provider.comsumer; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class OrderNacosMain8013 { public static void main(String[] args) { SpringApplication.run(OrderNacosMain8013.class, args); } } 测试 运行cloudAlibaba-provider-payment9001\n运行cloudAlibaba-provider-payment9002\n运行cloudalibaba-consumer-nacos-order8013\n","date":1597014000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597014000,"objectID":"11bde9b5ffcdc4e6b311f7c6647a736c","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E6%B3%A8%E5%86%8C%E5%92%8C%E8%B4%9F%E8%BD%BD/","publishdate":"2020-08-10T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E6%B3%A8%E5%86%8C%E5%92%8C%E8%B4%9F%E8%BD%BD/","section":"notes","summary":"新建项目 cloudalibaba-consumer-nacos-order8013\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 8013\rspring:\rapplication:\rname: nacos-order-consumer\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848\r#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）\rservice-url:\rnacos-user-service: http://nacos-payment-provider\rConfig nacos自带了负载均衡，所以需要加上@LoadBalanced注解\npackage com.cloud.provider.comsumer.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; /** * * @author yzg * @version 1.0 * @create 2020/08/10 */ @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } } controller package com.cloud.provider.comsumer.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.","tags":null,"title":"Nacos服务消费者注册和负载","type":"docs"},{"authors":null,"categories":null,"content":"什么是Bus 消息总线 Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。\nSpring cloud bus被国内很多都翻译为消息总线。可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ\n一张图来描述bus在配置中心使用的机制 这时Spring Cloud Bus做配置更新步骤如下:\n 提交代码触发post请求给bus/refresh server端接收到请求并发送给Spring Cloud Bus Spring Cloud bus接到消息并通知给其它客户端 其它客户端接收到通知，请求Server端获取最新配置 全部客户端均获取到最新的配置  ","date":1596499200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596499200,"objectID":"8aca9a3ad0db45ac39a02d64e547148a","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/bus/","publishdate":"2020-08-04T00:00:00Z","relpermalink":"/notes/cloud-study/bus/","section":"notes","summary":"什么是Bus 消息总线 Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。\nSpring cloud bus被国内很多都翻译为消息总线。可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ\n一张图来描述bus在配置中心使用的机制 这时Spring Cloud Bus做配置更新步骤如下:\n 提交代码触发post请求给bus/refresh server端接收到请求并发送给Spring Cloud Bus Spring Cloud bus接到消息并通知给其它客户端 其它客户端接收到通知，请求Server端获取最新配置 全部客户端均获取到最新的配置  ","tags":null,"title":"bus","type":"docs"},{"authors":null,"categories":null,"content":"Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n中文文档\n","date":1596499200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596499200,"objectID":"507a418fd3ebdb9c23efde95a77492b2","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/spring-cloud-alibaba-necos/","publishdate":"2020-08-04T00:00:00Z","relpermalink":"/notes/cloud-albaba/spring-cloud-alibaba-necos/","section":"notes","summary":"Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\n中文文档","tags":null,"title":"Necos","type":"docs"},{"authors":null,"categories":null,"content":"分布式配置中心 官网https://spring.io/projects/spring-cloud-config\n","date":1596412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596412800,"objectID":"474d1af40f5b1b5ff96d3cc4e21d33a8","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/config/","publishdate":"2020-08-03T00:00:00Z","relpermalink":"/notes/cloud-study/config/","section":"notes","summary":"分布式配置中心 官网https://spring.io/projects/spring-cloud-config","tags":null,"title":"config","type":"docs"},{"authors":null,"categories":null,"content":"什么是 Spring Cloud Gateway Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n#Spring Cloud Gateway 功能特征  基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 Predicates 和 Filters 作用于特定路由 集成 Hystrix 断路器 集成 Spring Cloud DiscoveryClient 易于编写的 Predicates 和 Filters 限流 路径重写  #Spring Cloud Gateway 工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。\n过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或之后（post）执行业务逻辑。\n","date":1596412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596412800,"objectID":"55836b8bc08d3bc2daedefb3aea26f54","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/gateway/","publishdate":"2020-08-03T00:00:00Z","relpermalink":"/notes/cloud-study/gateway/","section":"notes","summary":"什么是 Spring Cloud Gateway Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n#Spring Cloud Gateway 功能特征  基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0 动态路由 Predicates 和 Filters 作用于特定路由 集成 Hystrix 断路器 集成 Spring Cloud DiscoveryClient 易于编写的 Predicates 和 Filters 限流 路径重写  #Spring Cloud Gateway 工程流程 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。","tags":null,"title":"Gateway","type":"docs"},{"authors":null,"categories":null,"content":"Hystrix 是一个用于处理分布式系统的延迟和容错的开源库, 在分布式系统里, 许多依赖不可避免的会调用失败, 比如超时,异常等, Hystrix能够保证在一个依赖出问题的情况下, 不会导致整体服务失败, 避免级联故障, 以提高分布式系统的弹性.\n而\u0026quot;熔断器\u0026rdquo;,熔断器本身是一种开关装置, 当某个服务单元发生故障后, 通过断路器的故障监控(类似熔断保险丝), 向调用方返回一个符合预期的, 可处理的备选响应(FallBack), 而不是长时间的等待或者抛出调用方 无法处理的异常, 这样就保证了服务调用方的线程不会被长时间, 不必要地占用, 从而避免了故障在分布式系统中的蔓延, 乃至雪崩.\n服务降级 (例 :服务器忙, 请稍后再试) 遇到突发情况,异常,超时等,不让客户端等待并立刻返回一个友好提示,fallback\n哪些情况会发出降级措施  程序运行异常 超时 服务熔断触发服务降级 线程池/信号量分布式系统的延迟和容错的开源库, 在分布式系统里, 许多依赖不可避免的会调用失败, 比如超时,异常等, Hystrix能够保证在一个依赖出问题的情况下, 不会导致整体服务失败, 避免级联故障, 以提高分布式系统的弹性.  而\u0026quot;熔断器\u0026rdquo;,熔断器本身是一种开关装置, 当某个服务单元发生故障后, 通过断路器的故障监控(类似熔断保险丝), 向调用方返回一个符合预期的, 可处理的备选响应(FallBack), 而不是长时间的等待或者抛出调用方 无法处理的异常, 这样就保证了服务调用方的线程不会被长时间, 不必要地占用, 从而避免了故障在分布式系统中的蔓延, 乃至雪崩.\n服务降级 (例 :服务器忙, 请稍后再试) 遇到突发情况,异常,超时等,不让客户端等待并立刻返回一个友好提示,fallback\n哪些情况会发出降级措施  程序运行异常 超时 服务熔断触发服务降级 线程池/信号量满了也会导致服务降级  服务熔断 类似保险丝 当达到最大服务访问后, 直接拒绝访问, 直接拉闸, 然后调用服务降级的方法并返回一个友好提示\n服务降级-\u0026gt; 进而熔断 -\u0026gt; 恢复调用链路\n服务限流 秒杀高并发等操作, 严禁一窝蜂的拥挤,大家排队,一秒钟N个,有序进行\n","date":1595894400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595894400,"objectID":"51b08b8876ecdbaca2a5828910617e5e","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/hystrix/","publishdate":"2020-07-28T00:00:00Z","relpermalink":"/notes/cloud-study/hystrix/","section":"notes","summary":"Hystrix 是一个用于处理分布式系统的延迟和容错的开源库, 在分布式系统里, 许多依赖不可避免的会调用失败, 比如超时,异常等, Hystrix能够保证在一个依赖出问题的情况下, 不会导致整体服务失败, 避免级联故障, 以提高分布式系统的弹性.\n而\u0026quot;熔断器\u0026rdquo;,熔断器本身是一种开关装置, 当某个服务单元发生故障后, 通过断路器的故障监控(类似熔断保险丝), 向调用方返回一个符合预期的, 可处理的备选响应(FallBack), 而不是长时间的等待或者抛出调用方 无法处理的异常, 这样就保证了服务调用方的线程不会被长时间, 不必要地占用, 从而避免了故障在分布式系统中的蔓延, 乃至雪崩.\n服务降级 (例 :服务器忙, 请稍后再试) 遇到突发情况,异常,超时等,不让客户端等待并立刻返回一个友好提示,fallback\n哪些情况会发出降级措施  程序运行异常 超时 服务熔断触发服务降级 线程池/信号量分布式系统的延迟和容错的开源库, 在分布式系统里, 许多依赖不可避免的会调用失败, 比如超时,异常等, Hystrix能够保证在一个依赖出问题的情况下, 不会导致整体服务失败, 避免级联故障, 以提高分布式系统的弹性.  而\u0026quot;熔断器\u0026rdquo;,熔断器本身是一种开关装置, 当某个服务单元发生故障后, 通过断路器的故障监控(类似熔断保险丝), 向调用方返回一个符合预期的, 可处理的备选响应(FallBack), 而不是长时间的等待或者抛出调用方 无法处理的异常, 这样就保证了服务调用方的线程不会被长时间, 不必要地占用, 从而避免了故障在分布式系统中的蔓延, 乃至雪崩.\n服务降级 (例 :服务器忙, 请稍后再试) 遇到突发情况,异常,超时等,不让客户端等待并立刻返回一个友好提示,fallback\n哪些情况会发出降级措施  程序运行异常 超时 服务熔断触发服务降级 线程池/信号量满了也会导致服务降级  服务熔断 类似保险丝 当达到最大服务访问后, 直接拒绝访问, 直接拉闸, 然后调用服务降级的方法并返回一个友好提示\n服务降级-\u0026gt; 进而熔断 -\u0026gt; 恢复调用链路","tags":null,"title":"Hystrix","type":"docs"},{"authors":null,"categories":null,"content":"架构图 控制总线3344配置 cloud-config-center-3344\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml 添加 rabbitmq相关配置\n rabbitmq:\rhost: 203.176.95.155\rport: 8672\rusername: guest\rpassword: guest\r# 暴露bus刷新配置的端点\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;bus-refresh\u0026quot;\r客户端3355，3366配置 POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml 添加 rabbitmq相关配置\n rabbitmq:\rhost: 203.176.95.155\rport: 8672\rusername: guest\rpassword: guest\r测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n运行cloud-config-client-3366\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=3\u0026quot;\r给控制总线发送POST请求 curl -X POST \u0026ldquo;http://localhost:3344/actuator/bus-refresh\u0026rdquo;\n访问http://localhost:3344/master/config-dev.yml 访问http://localhost:3355/configInfo 访问http://localhost:3366/configInfo 查看rabbitMQ ","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"037eba7d2fbacd25872a27b0a3b2b2ff","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/bus%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/bus%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD/","section":"notes","summary":"架构图 控制总线3344配置 cloud-config-center-3344\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml 添加 rabbitmq相关配置\n rabbitmq:\rhost: 203.176.95.155\rport: 8672\rusername: guest\rpassword: guest\r# 暴露bus刷新配置的端点\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;bus-refresh\u0026quot;\r客户端3355，3366配置 POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-bus-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml 添加 rabbitmq相关配置\n rabbitmq:\rhost: 203.176.95.155\rport: 8672\rusername: guest\rpassword: guest\r测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n运行cloud-config-client-3366\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=3\u0026quot;\r给控制总线发送POST请求 curl -X POST \u0026ldquo;http://localhost:3344/actuator/bus-refresh\u0026rdquo;\n访问http://localhost:3344/master/config-dev.yml 访问http://localhost:3355/configInfo 访问http://localhost:3366/configInfo 查看rabbitMQ ","tags":null,"title":"bus动态刷新全局广播","type":"docs"},{"authors":null,"categories":null,"content":"公式 curl 配置中心地址(3344)/actuator/bus-refresh/{destination}\n案例 修改gitee上的config-dev.yml文件，只让3355刷新，3366不刷新\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n运行cloud-config-client-3366\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=4\u0026quot;\r发送请求 curl -X POST \u0026ldquo;http://localhost:3344/actuator/bus-refresh/config-client:3355\u0026rdquo;\n测试结果：3355刷新，3366不刷新\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"afcbfc132d04f37d5f1560e92f8e6778","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/bus%E5%8A%A8%E6%80%81%E5%AE%9A%E7%82%B9%E5%88%B7%E6%96%B0%E5%B9%BF%E6%92%AD/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/bus%E5%8A%A8%E6%80%81%E5%AE%9A%E7%82%B9%E5%88%B7%E6%96%B0%E5%B9%BF%E6%92%AD/","section":"notes","summary":"公式 curl 配置中心地址(3344)/actuator/bus-refresh/{destination}\n案例 修改gitee上的config-dev.yml文件，只让3355刷新，3366不刷新\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n运行cloud-config-client-3366\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=4\u0026quot;\r发送请求 curl -X POST \u0026ldquo;http://localhost:3344/actuator/bus-refresh/config-client:3355\u0026rdquo;\n测试结果：3355刷新，3366不刷新","tags":null,"title":"bus动态定点刷新广播","type":"docs"},{"authors":null,"categories":null,"content":"git仓库 cloud2020_config\nhttps://gitee.com/MrPen/cloud2020_config.git\n新建工程 cloud-config-center-3344\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server: port: 3344 spring: application: name: cloud-gateway cloud: config: server: git: #GitHub上面的git仓库名字 uri: https://gitee.com/MrPen/cloud2020_config.git  #搜索目录 search-paths: - cloud2020_config #读取分支 label: master eureka: instance: hostname: cloud-config-center client: fetch-registry: true register-with-eureka: true service-url: defaultZone: http://localhost:7001/eureka/  启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; /** * @author yzg */ @SpringBootApplication @EnableConfigServer public class ConfigCenterMain3344 { public static void main(String[] args) { SpringApplication.run(ConfigCenterMain3344.class, args); } } 测试 访问http://localhost:3344/master/config-dev.yml\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"88714cbbd39bcc178188ae7871b73515","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/config%E6%80%BB%E6%8E%A7%E4%B8%AD%E5%BF%83/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/config%E6%80%BB%E6%8E%A7%E4%B8%AD%E5%BF%83/","section":"notes","summary":"git仓库 cloud2020_config\nhttps://gitee.com/MrPen/cloud2020_config.git\n新建工程 cloud-config-center-3344\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server: port: 3344 spring: application: name: cloud-gateway cloud: config: server: git: #GitHub上面的git仓库名字 uri: https://gitee.com/MrPen/cloud2020_config.git  #搜索目录 search-paths: - cloud2020_config #读取分支 label: master eureka: instance: hostname: cloud-config-center client: fetch-registry: true register-with-eureka: true service-url: defaultZone: http://localhost:7001/eureka/  启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; /** * @author yzg */ @SpringBootApplication @EnableConfigServer public class ConfigCenterMain3344 { public static void main(String[] args) { SpringApplication.","tags":null,"title":"config总控中心","type":"docs"},{"authors":null,"categories":null,"content":"yml predicates: - Path=/payment/lb/** - Cookie=username,yzg 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud.provider.payment8002\n运行cloud-gateway-gateway9527\n访问curl http://localhost:9527/payment/lb\n访问curl http://localhost:9527/payment/lb \u0026ndash;cookie \u0026ldquo;username=yzg\u0026rdquo;\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"15aa19836aac362d719fe02e77d573e6","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/cookie%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E6%A1%88%E4%BE%8B/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/cookie%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E6%A1%88%E4%BE%8B/","section":"notes","summary":"yml predicates: - Path=/payment/lb/** - Cookie=username,yzg 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud.provider.payment8002\n运行cloud-gateway-gateway9527\n访问curl http://localhost:9527/payment/lb\n访问curl http://localhost:9527/payment/lb \u0026ndash;cookie \u0026ldquo;username=yzg\u0026rdquo;","tags":null,"title":"Cookie路由断言案例","type":"docs"},{"authors":null,"categories":null,"content":"新建项目cloud-gateway-gateway9527\nPOM \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;cloud-gateway-gateway9527\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;网失模块\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--gateway无需web和actuator --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; YML server:\rport: 9527\rspring:\rapplication:\rname: cloud-gateway\rcloud:\rgateway:\rdiscovery:\rlocator:\renabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由\rroutes:\r- id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名\r#匹配后提供服务的路由地址\ruri: http://localhost:8001\rpredicates:\r- Path=/payment/get/** # 断言，路径相匹配的进行路由\r- id: payment_route2\ruri: http://localhost:8001\rpredicates:\rPath=/payment/lb/** #断言,路径相匹配的进行路由\reureka:\rinstance:\rhostname: cloud-gateway-service\rclient:\rfetch-registry: true\rregister-with-eureka: true\rservice-url:\rdefaultZone: http://eureka7001.com:7001/eureka/\r启动类 package com.cloud.gateway; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; /** * @author yzg */ @SpringBootApplication @EnableEurekaClient public class GatewayMain9527 { public static void main(String[] args) { SpringApplication.run(GatewayMain9527.class, args); } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud-gateway-gateway9527\n访问http://localhost:8001/payment/get/1\n访问http://localhost:9527/payment/get/1\nconfig方式配置 新建GatewayConfig.java\npackage com.cloud.gateway.config; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 网关配置 * * @author yzg * @version 1.0 * @create 2020/08/03 */ @Configuration public class GatewayConfig { /** * 配置了一个id为route-name的路由规则 * 当访问localhost:9527/guonei的时候，将会转发至https://news.baidu.com/guonei * * @param routeLocatorBuilder * @return */ @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) { RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); return routes.route(\u0026#34;path_route_yzg\u0026#34;, r -\u0026gt; r.path(\u0026#34;/guonei\u0026#34;).uri(\u0026#34;https://news.baidu.com/guonei\u0026#34;)).build(); } @Bean public RouteLocator customRouteLocator2(RouteLocatorBuilder routeLocatorBuilder) { RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); return routes.route(\u0026#34;path_route_yzg\u0026#34;, r -\u0026gt; r.path(\u0026#34;/guoji\u0026#34;).uri(\u0026#34;https://news.baidu.com/guoji\u0026#34;)).build(); } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-gateway-gateway9527\n访问https://news.baidu.com/guonei 访问http://localhost:9527/guonei 点击国际\n点击军事 ","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"02c6de02a7571da93e0db4d2f6615bfd","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/gateway%E6%90%AD%E5%BB%BA/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/gateway%E6%90%AD%E5%BB%BA/","section":"notes","summary":"新建项目cloud-gateway-gateway9527\nPOM \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;cloud-gateway-gateway9527\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;网失模块\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--gateway无需web和actuator --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; YML server:\rport: 9527\rspring:\rapplication:\rname: cloud-gateway\rcloud:\rgateway:\rdiscovery:\rlocator:\renabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由\rroutes:\r- id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名\r#匹配后提供服务的路由地址\ruri: http://localhost:8001\rpredicates:\r- Path=/payment/get/** # 断言，路径相匹配的进行路由\r- id: payment_route2\ruri: http://localhost:8001\rpredicates:\rPath=/payment/lb/** #断言,路径相匹配的进行路由\reureka:\rinstance:\rhostname: cloud-gateway-service\rclient:\rfetch-registry: true\rregister-with-eureka: true\rservice-url:\rdefaultZone: http://eureka7001.","tags":null,"title":"Gateway搭建","type":"docs"},{"authors":null,"categories":null,"content":"新建配置类 package com.cloud.gateway.filter; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.Date; /** * 全局自定义过滤器 * * @author yzg * @version 1.0 * @create 2020/08/03 */ @Component @Slf4j public class MyLogGatewayFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { System.out.println(\u0026#34;come in global filter: {}\u0026#34;+ new Date()); ServerHttpRequest request = exchange.getRequest(); String uname = request.getQueryParams().getFirst(\u0026#34;uname\u0026#34;); if (uname == null) { System.out.println(\u0026#34;用户名为null，非法用户\u0026#34;); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); } // 放行  return chain.filter(exchange); } /** * 过滤器加载的顺序 越小,优先级别越高 * * @return */ @Override public int getOrder() { return 0; } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud.provider.payment8002\n运行cloud-gateway-gateway9527\n访问http://localhost:9527/payment/get/1\n访问http://localhost:9527/payment/get/1?uname=zs\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"bd3138481732f03d5b40550fe1a2b65d","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/gateway%E7%9A%84filter/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/gateway%E7%9A%84filter/","section":"notes","summary":"新建配置类 package com.cloud.gateway.filter; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.Date; /** * 全局自定义过滤器 * * @author yzg * @version 1.0 * @create 2020/08/03 */ @Component @Slf4j public class MyLogGatewayFilter implements GlobalFilter, Ordered { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { System.out.println(\u0026#34;come in global filter: {}\u0026#34;+ new Date()); ServerHttpRequest request = exchange.getRequest(); String uname = request.getQueryParams().getFirst(\u0026#34;uname\u0026#34;); if (uname == null) { System.","tags":null,"title":"Gateway的filter","type":"docs"},{"authors":null,"categories":null,"content":"修改项目cloud-gateway-gateway9527\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由\n cloud:\rgateway:\rdiscovery:\rlocator:\renabled: true 修改 uri\n - id: payment_route2\ruri: lb://CLOUD-PAYMENT-SERVICE\rpredicates:\rPath=/payment/lb/** #断言,路径相匹配的进行路由\r测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud.provider.payment8002\n运行cloud-gateway-gateway9527\n不断访问http://localhost:9527/payment/lb\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"9c08830be8725c8e553d1aeaa84c067d","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/gateway%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/gateway%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/","section":"notes","summary":"修改项目cloud-gateway-gateway9527\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 开启从注册中心动态创建路由的功能，利用微服务名称j进行路由\n cloud:\rgateway:\rdiscovery:\rlocator:\renabled: true 修改 uri\n - id: payment_route2\ruri: lb://CLOUD-PAYMENT-SERVICE\rpredicates:\rPath=/payment/lb/** #断言,路径相匹配的进行路由\r测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud.provider.payment8002\n运行cloud-gateway-gateway9527\n不断访问http://localhost:9527/payment/lb","tags":null,"title":"Gateway配置动态路由","type":"docs"},{"authors":null,"categories":null,"content":"理论 熔断机制是应对雪崩效应的一种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand，Hystrix会找有这个注解的方法，并将这类方法关联到和熔断器连在一起的代理上。当前，@HystrixCommand仅当类的注解为@Service或@Component时才会发挥作用。\n配置 项目cloud-hystrix-provider-payment8001\nservice /** * 在10秒窗口期中10次请求有6次是请求失败的,断路器将起作用 * @param id * @return */ @HystrixCommand( fallbackMethod = \u0026#34;paymentCircuitBreaker_fallback\u0026#34;, commandProperties = { @HystrixProperty(name = \u0026#34;circuitBreaker.enabled\u0026#34;, value = \u0026#34;true\u0026#34;),// 是否开启断路器  @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;),// 请求次数  @HystrixProperty(name = \u0026#34;circuitBreaker.sleepWindowInMilliseconds\u0026#34;, value = \u0026#34;10000\u0026#34;),// 时间窗口期/时间范文  @HystrixProperty(name = \u0026#34;circuitBreaker.errorThresholdPercentage\u0026#34;, value = \u0026#34;60\u0026#34;)// 失败率达到百分之60后跳闸  } ) public String paymentCircuitBreaker(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { if (id \u0026lt; 0) { throw new RuntimeException(\u0026#34;*****id不能是负数\u0026#34;); } String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName() + \u0026#34;\\t\u0026#34; + \u0026#34;调用成功,流水号:\u0026#34; + serialNumber; } public String paymentCircuitBreaker_fallback(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { return \u0026#34;id 不能负数,请稍后重试,o(╥﹏╥)o id:\u0026#34; + id; } controller /** * 服务熔断 * http://localhost:8001/payment/circuit/32 * @param id * @return */ @GetMapping(\u0026#34;/payment/circuit/{id}\u0026#34;) public String paymentCircuitBreaker(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { String result = paymentService.paymentCircuitBreaker(id); System.out.println(\u0026#34;***result:\u0026#34; + result); return result; } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-hystrix-provider-payment8001\n访问一次http://localhost:8001/payment/circuit/1\n多次访问http://localhost:8001/payment/circuit/-1\n再访问http://localhost:8001/payment/circuit/1\n小总结 （1）大神结论 （2）熔断类型  熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态 熔断关闭：熔断关闭不会对服务进行熔断 熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断  （3）断路器开启或者关闭的条件 @HystrixProperty(name = \u0026#34;circuitBreaker.enabled\u0026#34;, value = \u0026#34;true\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.sleepWindowInMilliseconds\u0026#34;, value = \u0026#34;10000\u0026#34;), @HystrixProperty(name = \u0026#34;circuitBreaker.errorThresholdPercentage\u0026#34;, value = \u0026#34;60\u0026#34;)//  当满足一定阀值的时候（默认10秒内超过20个请求次数） 当失败率达到一定的时候（默认10秒内超过50%请求失败） 到达以上阀值，断路器将会开启 当开启的时候，所有请求都不会进行转发 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5  ","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"28753c725e0cd6fb2527683a7d8f4006","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/","section":"notes","summary":"理论 熔断机制是应对雪崩效应的一种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand，Hystrix会找有这个注解的方法，并将这类方法关联到和熔断器连在一起的代理上。当前，@HystrixCommand仅当类的注解为@Service或@Component时才会发挥作用。\n配置 项目cloud-hystrix-provider-payment8001\nservice /** * 在10秒窗口期中10次请求有6次是请求失败的,断路器将起作用 * @param id * @return */ @HystrixCommand( fallbackMethod = \u0026#34;paymentCircuitBreaker_fallback\u0026#34;, commandProperties = { @HystrixProperty(name = \u0026#34;circuitBreaker.enabled\u0026#34;, value = \u0026#34;true\u0026#34;),// 是否开启断路器  @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;),// 请求次数  @HystrixProperty(name = \u0026#34;circuitBreaker.sleepWindowInMilliseconds\u0026#34;, value = \u0026#34;10000\u0026#34;),// 时间窗口期/时间范文  @HystrixProperty(name = \u0026#34;circuitBreaker.errorThresholdPercentage\u0026#34;, value = \u0026#34;60\u0026#34;)// 失败率达到百分之60后跳闸  } ) public String paymentCircuitBreaker(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { if (id \u0026lt; 0) { throw new RuntimeException(\u0026#34;*****id不能是负数\u0026#34;); } String serialNumber = IdUtil.","tags":null,"title":"Hystrix服务熔断","type":"docs"},{"authors":null,"categories":null,"content":"新建项目cloud-consumer-hystrix-dashboard9001\nPOM \u0026lt;!--hystrix dashboard--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--actuator监控信息完善--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML server:\rport: 9001\r启动类 package com.cloud.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard; import org.springframework.context.annotation.Bean; import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet; /** * @author yzg * @create 2020/7/30 10:27 **/ @SpringBootApplication @EnableHystrixDashboard public class HystrixDashboardMain9001 { public static void main(String[] args) { SpringApplication.run(HystrixDashboardMain9001.class); } /** * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑 * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream * 只要在自己的项目中配置上下面的servlet即可 * @return */ @Bean public ServletRegistrationBean getServlet(){ HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean\u0026lt;HystrixMetricsStreamServlet\u0026gt; registrationBean = new ServletRegistrationBean\u0026lt;\u0026gt;(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\u0026#34;/hystrix.stream\u0026#34;); registrationBean.setName(\u0026#34;HystrixMetricsStreamServlet\u0026#34;); return registrationBean; } } 访问http://localhost:9001/hystrix\n监控8001 配置cloud-hystrix-provider-payment8001\n添加pom\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改启动类\npackage com.cloud.provider.payment; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.context.annotation.Bean; import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet; @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication @EnableCircuitBreaker @MapperScan(\u0026#34;com.cloud.provider.payment.dao\u0026#34;) public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class, args); } @Bean public ServletRegistrationBean getServlet(){ HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean\u0026lt;HystrixMetricsStreamServlet\u0026gt; registrationBean = new ServletRegistrationBean\u0026lt;\u0026gt;(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\u0026#34;/hystrix.stream\u0026#34;); registrationBean.setName(\u0026#34;HystrixMetricsStreamServlet\u0026#34;); return registrationBean; } } 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-hystrix-provider-payment8001\n运行cloud-consumer-hystrix-dashboard9001\n不断访问http://localhost:8001/payment/circuit/1\n不断访问http://localhost:8001/payment/circuit/-1\n访问http://localhost:9001/hystrix\n输入http://localhost:8001/hystrix.stream\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"72fa6ed2857d6bfc07f71d6632bca89a","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/","section":"notes","summary":"新建项目cloud-consumer-hystrix-dashboard9001\nPOM \u0026lt;!--hystrix dashboard--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--actuator监控信息完善--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML server:\rport: 9001\r启动类 package com.cloud.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard; import org.springframework.context.annotation.Bean; import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet; /** * @author yzg * @create 2020/7/30 10:27 **/ @SpringBootApplication @EnableHystrixDashboard public class HystrixDashboardMain9001 { public static void main(String[] args) { SpringApplication.run(HystrixDashboardMain9001.class); } /** * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑 * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream * 只要在自己的项目中配置上下面的servlet即可 * @return */ @Bean public ServletRegistrationBean getServlet(){ HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean\u0026lt;HystrixMetricsStreamServlet\u0026gt; registrationBean = new ServletRegistrationBean\u0026lt;\u0026gt;(streamServlet); registrationBean.","tags":null,"title":"Hystrix服务监控","type":"docs"},{"authors":null,"categories":null,"content":"提供端降级 项目：cloud-hystrix-provider-payment8001\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; service 编写fallbackMethod方法payment_TimeOutHandler()\n@HystrixCommand进行调用\n @HystrixProperty服务超时限制\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; @HystrixCommand(fallbackMethod = \u0026#34;payment_TimeOutHandler\u0026#34;, commandProperties = { @HystrixProperty(name = \u0026#34;execution.isolation.thread.timeoutInMilliseconds\u0026#34;, value = \u0026#34;3000\u0026#34;) }) public String paymentInfo_TimeOut(Integer id) { int timeNumber = 5; try { // 暂停5秒钟  TimeUnit.SECONDS.sleep(timeNumber); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_TimeOut,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~ 耗时(秒)\u0026#34; + timeNumber; } public String payment_TimeOutHandler(Integer id) { return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; 系统繁忙或运行错误,请稍后重试,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;o(╥﹏╥)o\u0026#34;; } 启动类 添加@EnableCircuitBreaker注解\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-hystrix-provider-payment8001\n访问http://localhost:8001/payment/hystrix/ok/1 （正常请求）\n访问http://localhost:8001/payment/hystrix/timeout/1 （超时请求）\n消费端降级 项目：cloud-openfeign-hystrix-comsumer-order8011\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置全局服务降级 OrderController添加全局服务降级\n@DefaultProperties(defaultFallback = \u0026#34;payment_Global_FallbackMethod\u0026#34;) public String payment_Global_FallbackMethod() { return \u0026#34;Global异常处理信息,请稍后重试.o(╥﹏╥)o\u0026#34;; } 配置通配服务降级 添加PaymentFallbackService实现PaymentFeignService接口\npackage com.cloud.comsumer.order.service.falkback; import org.springframework.stereotype.Component; import com.cloud.comsumer.order.service.PaymentFeignService; /** * @author yzg * @create 2020/7/28 16:01 **/ @Component public class PaymentFallbackService implements PaymentFeignService { @Override public String paymentInfo_OK(Integer id) { return \u0026#34;----PaymentFallbackService fall back-paymentInfo_OK,o(╥﹏╥)o\u0026#34;; } @Override public String paymentInfo_TimeOut(Integer id) { return \u0026#34;----PaymentFallbackService fall back-paymentInfo_TimeOut,o(╥﹏╥)o\u0026#34;; } } yml feign:\rhystrix:\r# 在feign中开启Hystrix\renabled: true\r启动类 添加@EnableHystrix注解\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"66aaeb4e61b6cd1e97c9591f4e1c23ce","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/","section":"notes","summary":"提供端降级 项目：cloud-hystrix-provider-payment8001\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; service 编写fallbackMethod方法payment_TimeOutHandler()\n@HystrixCommand进行调用\n @HystrixProperty服务超时限制\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand; import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty; @HystrixCommand(fallbackMethod = \u0026#34;payment_TimeOutHandler\u0026#34;, commandProperties = { @HystrixProperty(name = \u0026#34;execution.isolation.thread.timeoutInMilliseconds\u0026#34;, value = \u0026#34;3000\u0026#34;) }) public String paymentInfo_TimeOut(Integer id) { int timeNumber = 5; try { // 暂停5秒钟  TimeUnit.SECONDS.sleep(timeNumber); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_TimeOut,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~ 耗时(秒)\u0026#34; + timeNumber; } public String payment_TimeOutHandler(Integer id) { return \u0026#34;线程池:\u0026#34; + Thread.","tags":null,"title":"Hystrix服务降级","type":"docs"},{"authors":null,"categories":null,"content":"下载镜像 docker pull nacos/nacos-server 启动 docker run --env MODE=standalone --name nacos -d -p 8848:8848 -v /opt/nacos/conf:/home/nacos/conf nacos/nacos-server:latest 使用docker-compose启动  配置文件  docker-compose文件 standalone-derby.yaml\nversion: \u0026#34;2\u0026#34; services: nacos: image: nacos/nacos-server:latest container_name: nacos environment: - MODE=standalone volumes: - /opt/nacos/logs:/home/nacos/logs - /opt/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties ports: - \u0026#34;8848:8848\u0026#34;  启动  docker-compose -f standalone-derby.yaml up  关闭  docker-compose -f standalone-derby.yaml stop  移除  docker-compose -f standalone-derby.yaml rm  关闭且移除  docker-compose -f standalone-derby.yaml down 测试访问 直接访问 http://127.0.0.1:8848/nacos， 使用账号：nacos，密码：nacos 直接登录。nacos是默认账号和密码，登录成功后可以修改密码。\n/home/nacos/conf\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"66459e2c7d8f9cf68db1ec02493b2a7e","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/nacos%E5%AE%89%E8%A3%85/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/nacos%E5%AE%89%E8%A3%85/","section":"notes","summary":"下载镜像 docker pull nacos/nacos-server 启动 docker run --env MODE=standalone --name nacos -d -p 8848:8848 -v /opt/nacos/conf:/home/nacos/conf nacos/nacos-server:latest 使用docker-compose启动  配置文件  docker-compose文件 standalone-derby.yaml\nversion: \u0026#34;2\u0026#34; services: nacos: image: nacos/nacos-server:latest container_name: nacos environment: - MODE=standalone volumes: - /opt/nacos/logs:/home/nacos/logs - /opt/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties ports: - \u0026#34;8848:8848\u0026#34;  启动  docker-compose -f standalone-derby.yaml up  关闭  docker-compose -f standalone-derby.yaml stop  移除  docker-compose -f standalone-derby.yaml rm  关闭且移除  docker-compose -f standalone-derby.yaml down 测试访问 直接访问 http://127.","tags":null,"title":"Nacos安装.","type":"docs"},{"authors":null,"categories":null,"content":"官方文档\n新建项目 cloudAlibaba-provider-payment9001\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 9001\rspring:\rapplication:\rname: nacos-payment-provider\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot;\r启动类 package com.cloud.provider.payment; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient @MapperScan(\u0026#34;com.cloud.provider.payment.dao\u0026#34;) public class PaymentMain9001 { public static void main(String[] args) { SpringApplication.run(PaymentMain9001.class, args); } } 测试 运行cloudAlibaba-provider-payment9001\n访问http://localhost:8848/nacos\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"285f7192557932ef4ca6736ccb52ad8c","permalink":"https://academia-hugo.netlify.com/notes/cloud-albaba/%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%B3%A8%E5%86%8C/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-albaba/%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%B3%A8%E5%86%8C/","section":"notes","summary":"官方文档\n新建项目 cloudAlibaba-provider-payment9001\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 9001\rspring:\rapplication:\rname: nacos-payment-provider\rcloud:\rnacos:\rdiscovery:\rserver-addr: localhost:8848\rmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot;\r启动类 package com.cloud.provider.payment; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient @MapperScan(\u0026#34;com.cloud.provider.payment.dao\u0026#34;) public class PaymentMain9001 { public static void main(String[] args) { SpringApplication.run(PaymentMain9001.class, args); } } 测试 运行cloudAlibaba-provider-payment9001\n访问http://localhost:8848/nacos","tags":null,"title":"Nacos服务消费者注册","type":"docs"},{"authors":null,"categories":null,"content":"config package com.cloud.comsumer.order.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * OpenFeignClient配置 * * @author yzg * @create 2020/7/28 11:02 **/ @Configuration public class FeignConfig { /** * feignClient配置日志级别 * * @return */ @Bean public Logger.Level feignLoggerLevel() { // 请求和响应的头信息,请求和响应的正文及元数据  return Logger.Level.FULL; } } yml logging:\rlevel:\rcom.cloud.comsumer.order.service.PaymentFeignService: debug\rtest 启动cloud-eureka-server7001\n启动cloud-eureka-server7002\n启动cloud.provider.payment8001\n启动cloud-openfeign-comsumer-order8011\n访问http://localhost:8011/consumer/payment/get/1\n日志输出\n2020-07-28 11:07:26.273 INFO 14276 --- [nio-8011-exec-1] o.apache.tomcat.util.http.parser.Cookie : A cookie header was received [1586915103; CNZZDATA1277660940=1307569842-1585038106-%7C1586919560; rememberMe=nCK4RXlTmL26pgnrtHvtoebs5N83CQ942qOySZo8nv8h21PIE064HmqCrClwl6ECxwmd1L77k80eqb0YxaS9j3oiwY5VKvQwe5rP3RKYodwpQJVfKcB2icYCYDQQoYqX8SgzLWZv4pyQiI3gy8sHJ7XZJ1hKEmfqYUJV21Yb8BDeW2Gdx3mZQjOUCrIzo6RdxeZNUKToxP+mcA/RR4RW+16TjDImWfkVFmCMiTecHP8gkQhHOq8ut28eaebWM5cSmaqCl0p116NsOcsCOqyBWOixdLPFg1P3V1qCRtIPnCCdNdDhslldApu58arhQfP/26msRD/pEB9wsWG9ICmvRg8AAabJGZVvLgEV5cVdn5xg6DrYgZLySwrCk24iQuQ6K8kFOP42VbwV+sV8DCgubhcaoQZYpUYM7uoaR8XSEGXQaic+u5ih7h6M46aCw4srtAFEPUuh++6bQ+xUiia8D198wOCIKMPx7owTTFzTAwpIeUrtNVvUJDuRaNtNvqbqEpaOPu6O8VBrAenJ9aVe7QEGCW2iDgrb7igeBYaXM0UKJar0QpWwuMSH1lxOFRl2aNN76wKwX4RCGun4C2E/vkZxg4/VQJ4vE+qhw91yvZrnGMF0uQfeS/VQBiGR2G+aJE/8Mda7lBdOjHWkFLDN1IaJhAMhK9TEwdZEk/2fgmKXcU4Lma0yzjyueBVT2cdq2Oki0IKgkadbcRTSPIdbHlVs+2MG9MTfJ8A2YS/UJJtPbjHxS0JarAoRMkwPHdNqz/Zr+AmV14W/OJm4k61orniYuDxAttVHsxvNGNom/ajpbHjD9WvCQpiJAi/xpkXoWkgBVhOuXvEsiJjzz680C34zffr17RX++tO59cOBFCAdFeGXTyVnSMe+/frwXjL4/4+wyP2WAGMwQCcXOXKINKV4BMHKCt99B7q0eAt0u05u4uFNnXX01IRPfxuilKvAFe4/XQ0DAjooQZi/141N9R9eIu6PKortynnc8uSVr1TU6rLcksOd8IkxiJYikr9b2cnetvvJCLmsBZ5qhzpuidegb/pomnYjWEm0YbawAT0mt+/FqE3AOHQXpr5kC+TA/LtnFc9MnwNJsbzfTidSCBox678Y7gEh6HNNyKPSDoJ1IjAPaPKotdmnNGSlIeVyOPd5jeCBxerOZW5NmwNzu527NZxEDc5TRJd1NqfyAVCYp3oFQVkn07vu8tE8XO4nB1KFRMTpDJJGZtEwYaN2o3gUSMsX6jYb/vSEF+SDekPSY29vbqRstVh5BDQmAItxoTobIArbI4CaRCT23Y8+plneEgknthqP0xDYkXRmesRDs5YMGX7rIKbVAwf7vh3r3rnHJhY35l5XsIvBCznkLPXxfSyaGd4BFV6UMIcZhpJOruTWQ/Y0ftuXo3xniyIrZa4aX1kx1CRIJrwD1DyjSJVdE58Sn3mNfXiWqVdo0J3nJaQ1jBEEwTY2camXmcPZbtlZNkNbhXoXkdFuNpUoTnnfMhaF8r3x+mk+uhk4T86MNkexAid5KLbg5cy9jLqc8Sj7yc97BnzZSFMNNmGn4ya10a4Wm+ba4w/LPxYhpetAmK2je+OptpMzZnT0v+GfxZMTYYJX0AsBSEadZOzJf3p1g9k+15pG7Bj8O0I/FEAhARkWrzohNKqqFI53Tb/iNdLpradnQfEYLZ2wlyLgJq5Z76ZZMwUT/Dotz2DAreayE8uxmsY8whtAdiopVftnpi1qR4DDeu7NinkWul97RgzGhNXZ8miDLpRtDz2XOyvx+49l1vlVZH44uYfd3mNxAcGY2KBRuxiGMBcF5HawBL0SdXqk+zSFhnYO4YcHGvPpQdaTfW6qtOvXAZUzV38n4zGJRROAZFjuzzbCUZY5Q9Vz3spA3VfMgEwIWJ5HTT9GKajVSorbYF1lNrKHeBqHfEUnxKO4fbwPewH0+cLXMCXEAagUTggjxAu3kjSLa6AuUO6N6trxKZ2LV5GcsYzbRLXiXLwjVj1gxZxiKpPus3Yo81dfo9h6w7yuviPWZuMEGaIhgSBzWDenE+wjLbKx3CEbNPtHW4i6JOCAMYuWGa44WCCyh33Xmvw13HfVPnrSpeH95JNvMCM0KVF3jsDzGKC9vgrxh2N36Twbb0TqMJ9sKuirQMli89xKwukKnyKP6msJHOMaoZUHWxVJ/vXURY/ZP0iK1raGtOLZ3dt2620pfbLo9yDRJY/vjYcAAl1hezdbV/08w5tdPGoM9RUNVEYPTjmZodhU3Fdm8Ta2c1BsGxuL4ONR/e4yRwztcMZpe740pq7UsfHZtcdgiiAmTWSy8zOIcRzkGyyWGcc19ZYxiZc19bv3Qgd8HsliICfCwlQOHwgpI3obKiBAyzpz21Rtg0XhQxbaaghurW+ne8ELLyihJ/UfpIIyQtR1Q4rbyQ48zzBunicpp9Qjj/eiBhGQXeRwnlwtmySI2/DZM/YxLdHxzQkjJxUYb2lqJBgPV/3xP+Q8wXr3AOoFBe4otnmcpHFa6DahMooLGAXcQkMsek7JrXL+RMUDVMn6raYPdyUcM9PtwaQn4wn0Mg==] that contained an invalid cookie. That cookie will be ignored.\rNote: further occurrences of this error will be logged at DEBUG level.\r2020-07-28 11:07:26.288 INFO 14276 --- [nio-8011-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'\r2020-07-28 11:07:26.288 INFO 14276 --- [nio-8011-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'\r2020-07-28 11:07:26.299 INFO 14276 --- [nio-8011-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 11 ms\r2020-07-28 11:07:26.592 INFO 14276 --- [nio-8011-exec-1] c.netflix.config.ChainedDynamicProperty : Flipping property: CLOUD-PAYMENT-SERVICE.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647\r2020-07-28 11:07:26.635 INFO 14276 --- [nio-8011-exec-1] c.n.u.concurrent.ShutdownEnabledTimer : Shutdown hook installed for: NFLoadBalancer-PingTimer-CLOUD-PAYMENT-SERVICE\r2020-07-28 11:07:26.635 INFO 14276 --- [nio-8011-exec-1] c.netflix.loadbalancer.BaseLoadBalancer : Client: CLOUD-PAYMENT-SERVICE instantiated a LoadBalancer: DynamicServerListLoadBalancer:{NFLoadBalancer:name=CLOUD-PAYMENT-SERVICE,current list of Servers=[],Load balancer stats=Zone stats: {},Server stats: []}ServerList:null\r2020-07-28 11:07:26.650 INFO 14276 --- [nio-8011-exec-1] c.n.l.DynamicServerListLoadBalancer : Using serverListUpdater PollingServerListUpdater\r2020-07-28 11:07:26.674 INFO 14276 --- [nio-8011-exec-1] c.netflix.config.ChainedDynamicProperty : Flipping property: CLOUD-PAYMENT-SERVICE.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647\r2020-07-28 11:07:26.676 INFO 14276 --- [nio-8011-exec-1] c.n.l.DynamicServerListLoadBalancer : DynamicServerListLoadBalancer for client CLOUD-PAYMENT-SERVICE initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=CLOUD-PAYMENT-SERVICE,current list of Servers=[USER-20200308JZ:8002, USER-20200308JZ:8001],Load balancer stats=Zone stats: {defaultzone=[Zone:defaultzone;\tInstance count:2;\tActive connections count: 0;\tCircuit breaker tripped count: 0;\tActive connections per server: 0.0;]\r},Server stats: [[Server:USER-20200308JZ:8002;\tZone:defaultZone;\tTotal Requests:0;\tSuccessive connection failure:0;\tTotal blackout seconds:0;\tLast connection made:Thu Jan 01 08:00:00 CST 1970;\tFirst connection made: Thu Jan 01 08:00:00 CST 1970;\tActive Connections:0;\ttotal failure count in last (1000) msecs:0;\taverage resp time:0.0;\t90 percentile resp time:0.0;\t95 percentile resp time:0.0;\tmin resp time:0.0;\tmax resp time:0.0;\tstddev resp time:0.0]\r, [Server:USER-20200308JZ:8001;\tZone:defaultZone;\tTotal Requests:0;\tSuccessive connection failure:0;\tTotal blackout seconds:0;\tLast connection made:Thu Jan 01 08:00:00 CST 1970;\tFirst connection made: Thu Jan 01 08:00:00 CST 1970;\tActive Connections:0;\ttotal failure count in last (1000) msecs:0;\taverage resp time:0.0;\t90 percentile resp time:0.0;\t95 percentile resp time:0.0;\tmin resp time:0.0;\tmax resp time:0.0;\tstddev resp time:0.0]\r]}ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@27f28632\r2020-07-28 11:07:27.656 INFO 14276 --- [erListUpdater-0] c.netflix.config.ChainedDynamicProperty : Flipping property: CLOUD-PAYMENT-SERVICE.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647\r","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"f7ae169fae65507541cfe772a60634ea","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/openfeign%E6%97%A5%E5%BF%97%E5%A2%9E%E5%BC%BA/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/openfeign%E6%97%A5%E5%BF%97%E5%A2%9E%E5%BC%BA/","section":"notes","summary":"config package com.cloud.comsumer.order.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * OpenFeignClient配置 * * @author yzg * @create 2020/7/28 11:02 **/ @Configuration public class FeignConfig { /** * feignClient配置日志级别 * * @return */ @Bean public Logger.Level feignLoggerLevel() { // 请求和响应的头信息,请求和响应的正文及元数据  return Logger.Level.FULL; } } yml logging:\rlevel:\rcom.cloud.comsumer.order.service.PaymentFeignService: debug\rtest 启动cloud-eureka-server7001\n启动cloud-eureka-server7002\n启动cloud.provider.payment8001\n启动cloud-openfeign-comsumer-order8011\n访问http://localhost:8011/consumer/payment/get/1\n日志输出\n2020-07-28 11:07:26.273 INFO 14276 --- [nio-8011-exec-1] o.apache.tomcat.util.http.parser.Cookie : A cookie header was received [1586915103; CNZZDATA1277660940=1307569842-1585038106-%7C1586919560; rememberMe=nCK4RXlTmL26pgnrtHvtoebs5N83CQ942qOySZo8nv8h21PIE064HmqCrClwl6ECxwmd1L77k80eqb0YxaS9j3oiwY5VKvQwe5rP3RKYodwpQJVfKcB2icYCYDQQoYqX8SgzLWZv4pyQiI3gy8sHJ7XZJ1hKEmfqYUJV21Yb8BDeW2Gdx3mZQjOUCrIzo6RdxeZNUKToxP+mcA/RR4RW+16TjDImWfkVFmCMiTecHP8gkQhHOq8ut28eaebWM5cSmaqCl0p116NsOcsCOqyBWOixdLPFg1P3V1qCRtIPnCCdNdDhslldApu58arhQfP/26msRD/pEB9wsWG9ICmvRg8AAabJGZVvLgEV5cVdn5xg6DrYgZLySwrCk24iQuQ6K8kFOP42VbwV+sV8DCgubhcaoQZYpUYM7uoaR8XSEGXQaic+u5ih7h6M46aCw4srtAFEPUuh++6bQ+xUiia8D198wOCIKMPx7owTTFzTAwpIeUrtNVvUJDuRaNtNvqbqEpaOPu6O8VBrAenJ9aVe7QEGCW2iDgrb7igeBYaXM0UKJar0QpWwuMSH1lxOFRl2aNN76wKwX4RCGun4C2E/vkZxg4/VQJ4vE+qhw91yvZrnGMF0uQfeS/VQBiGR2G+aJE/8Mda7lBdOjHWkFLDN1IaJhAMhK9TEwdZEk/2fgmKXcU4Lma0yzjyueBVT2cdq2Oki0IKgkadbcRTSPIdbHlVs+2MG9MTfJ8A2YS/UJJtPbjHxS0JarAoRMkwPHdNqz/Zr+AmV14W/OJm4k61orniYuDxAttVHsxvNGNom/ajpbHjD9WvCQpiJAi/xpkXoWkgBVhOuXvEsiJjzz680C34zffr17RX++tO59cOBFCAdFeGXTyVnSMe+/frwXjL4/4+wyP2WAGMwQCcXOXKINKV4BMHKCt99B7q0eAt0u05u4uFNnXX01IRPfxuilKvAFe4/XQ0DAjooQZi/141N9R9eIu6PKortynnc8uSVr1TU6rLcksOd8IkxiJYikr9b2cnetvvJCLmsBZ5qhzpuidegb/pomnYjWEm0YbawAT0mt+/FqE3AOHQXpr5kC+TA/LtnFc9MnwNJsbzfTidSCBox678Y7gEh6HNNyKPSDoJ1IjAPaPKotdmnNGSlIeVyOPd5jeCBxerOZW5NmwNzu527NZxEDc5TRJd1NqfyAVCYp3oFQVkn07vu8tE8XO4nB1KFRMTpDJJGZtEwYaN2o3gUSMsX6jYb/vSEF+SDekPSY29vbqRstVh5BDQmAItxoTobIArbI4CaRCT23Y8+plneEgknthqP0xDYkXRmesRDs5YMGX7rIKbVAwf7vh3r3rnHJhY35l5XsIvBCznkLPXxfSyaGd4BFV6UMIcZhpJOruTWQ/Y0ftuXo3xniyIrZa4aX1kx1CRIJrwD1DyjSJVdE58Sn3mNfXiWqVdo0J3nJaQ1jBEEwTY2camXmcPZbtlZNkNbhXoXkdFuNpUoTnnfMhaF8r3x+mk+uhk4T86MNkexAid5KLbg5cy9jLqc8Sj7yc97BnzZSFMNNmGn4ya10a4Wm+ba4w/LPxYhpetAmK2je+OptpMzZnT0v+GfxZMTYYJX0AsBSEadZOzJf3p1g9k+15pG7Bj8O0I/FEAhARkWrzohNKqqFI53Tb/iNdLpradnQfEYLZ2wlyLgJq5Z76ZZMwUT/Dotz2DAreayE8uxmsY8whtAdiopVftnpi1qR4DDeu7NinkWul97RgzGhNXZ8miDLpRtDz2XOyvx+49l1vlVZH44uYfd3mNxAcGY2KBRuxiGMBcF5HawBL0SdXqk+zSFhnYO4YcHGvPpQdaTfW6qtOvXAZUzV38n4zGJRROAZFjuzzbCUZY5Q9Vz3spA3VfMgEwIWJ5HTT9GKajVSorbYF1lNrKHeBqHfEUnxKO4fbwPewH0+cLXMCXEAagUTggjxAu3kjSLa6AuUO6N6trxKZ2LV5GcsYzbRLXiXLwjVj1gxZxiKpPus3Yo81dfo9h6w7yuviPWZuMEGaIhgSBzWDenE+wjLbKx3CEbNPtHW4i6JOCAMYuWGa44WCCyh33Xmvw13HfVPnrSpeH95JNvMCM0KVF3jsDzGKC9vgrxh2N36Twbb0TqMJ9sKuirQMli89xKwukKnyKP6msJHOMaoZUHWxVJ/vXURY/ZP0iK1raGtOLZ3dt2620pfbLo9yDRJY/vjYcAAl1hezdbV/08w5tdPGoM9RUNVEYPTjmZodhU3Fdm8Ta2c1BsGxuL4ONR/e4yRwztcMZpe740pq7UsfHZtcdgiiAmTWSy8zOIcRzkGyyWGcc19ZYxiZc19bv3Qgd8HsliICfCwlQOHwgpI3obKiBAyzpz21Rtg0XhQxbaaghurW+ne8ELLyihJ/UfpIIyQtR1Q4rbyQ48zzBunicpp9Qjj/eiBhGQXeRwnlwtmySI2/DZM/YxLdHxzQkjJxUYb2lqJBgPV/3xP+Q8wXr3AOoFBe4otnmcpHFa6DahMooLGAXcQkMsek7JrXL+RMUDVMn6raYPdyUcM9PtwaQn4wn0Mg==] that contained an invalid cookie.","tags":null,"title":"openfeign日志增强","type":"docs"},{"authors":null,"categories":null,"content":"提供端 故意在提供方cloud.provider.payment8001写个方法，相应时间为3秒\n@GetMapping(value = \u0026#34;/payment/feign/timeout\u0026#34;) public String paymentFeignTimeout() { try { // 暂停3秒钟  TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return serverPort; } } 消费端 在消费端内调用该方法\nPaymentFeignService.java\n@GetMapping(value = \u0026#34;/payment/feign/timeout\u0026#34;) public String paymentFeignTimeout(); OrderController.java\n@GetMapping(\u0026#34;/consumer/fegin/timeout\u0026#34;) public String paymentTimeOut() { return paymentFeignService.paymentFeignTimeout(); } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud-openfeign-comsumer-order8011\n访问提供端：http://localhost:8001/payment/feign/timeout 访问消费端：http://localhost:8011/consumer/fegin/timeout\n修改配置 修改消费端的yml配置文件，添加以下配置\n5000代表5秒\napplication.yml\nribbon:\r# 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间\rReadTimeout: 5000\r# 指的是建立连接后从服务器读取到可用资源所用的时间\rConnectTimeout: 5000\r测试 重启cloud-openfeign-comsumer-order8011\n访问消费端：http://localhost:8011/consumer/fegin/timeout\n总结 1.openfeign客户端默认等待的时间是1秒\n2.可以通过修改application.yml配置文件来进行超时控制\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"4b9626d7a66714708fd661a1aa8d3243","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/openfeign%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/openfeign%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/","section":"notes","summary":"提供端 故意在提供方cloud.provider.payment8001写个方法，相应时间为3秒\n@GetMapping(value = \u0026#34;/payment/feign/timeout\u0026#34;) public String paymentFeignTimeout() { try { // 暂停3秒钟  TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return serverPort; } } 消费端 在消费端内调用该方法\nPaymentFeignService.java\n@GetMapping(value = \u0026#34;/payment/feign/timeout\u0026#34;) public String paymentFeignTimeout(); OrderController.java\n@GetMapping(\u0026#34;/consumer/fegin/timeout\u0026#34;) public String paymentTimeOut() { return paymentFeignService.paymentFeignTimeout(); } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001\n运行cloud-openfeign-comsumer-order8011\n访问提供端：http://localhost:8001/payment/feign/timeout 访问消费端：http://localhost:8011/consumer/fegin/timeout\n修改配置 修改消费端的yml配置文件，添加以下配置\n5000代表5秒\napplication.yml\nribbon:\r# 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间\rReadTimeout: 5000\r# 指的是建立连接后从服务器读取到可用资源所用的时间\rConnectTimeout: 5000\r测试 重启cloud-openfeign-comsumer-order8011\n访问消费端：http://localhost:8011/consumer/fegin/timeout\n总结 1.openfeign客户端默认等待的时间是1秒\n2.可以通过修改application.yml配置文件来进行超时控制","tags":null,"title":"openfeign超时控制","type":"docs"},{"authors":null,"categories":null,"content":"原文地址：https://www.cnblogs.com/fengyumeng/p/11133924.html\n安装erlang 由于rabbitmq是基于erlang语言开发的，所以必须先安装erlang。\n安装依赖\nyum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel erlang官网：\nhttps://www.erlang.org/downloads\n下载（会比较慢，请耐心等待）\nwget http://erlang.org/download/otp_src_22.0.tar.gz 解压\ntar -zxvf otp_src_22.0.tar.gz 移走\nmv otp_src_22.0 /usr/local/ 切换目录\ncd /usr/local/otp_src_22.0/\r创建即将安装的目录\nmkdir ../erlang 配置安装路径\n./configure --prefix=/usr/local/erlang 如果遇到这个错 你就假装没看到\n安装\nmake install 查看一下是否安装成功\nll /usr/local/erlang/bin 添加环境变量\necho 'export PATH=$PATH:/usr/local/erlang/bin' \u0026gt;\u0026gt; /etc/profile\r刷新环境变量\nsource /etc/profile 甩一条命令\nerl 瞬间进入了一个未知的世界\n在里面输入halt().命令退出来（那个点号别忘记）\n安装RabbitMQ rabbitmq下载地址：\nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.15\n下载\nwget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.15/rabbitmq-server-generic-unix-3.7.15.tar.xz 由于是tar.xz格式的所以需要用到xz，没有的话就先安装\nyum install -y xz 第一次解压\n/bin/xz -d rabbitmq-server-generic-unix-3.7.15.tar.xz 第二次解压\ntar -xvf rabbitmq-server-generic-unix-3.7.15.tar 移走\nmv rabbitmq_server-3.7.15/ /usr/local/ 改名\nmv /usr/local/rabbitmq_server-3.7.15 rabbitmq 配置环境变量\necho \u0026#39;export PATH=$PATH:/usr/local/rabbitmq/sbin\u0026#39; \u0026gt;\u0026gt; /etc/profile 刷新环境变量\nsource /etc/profile 创建配置目录\nmkdir /etc/rabbitmq 启动命令 启动：\nrabbitmq-server -detached 停止：\nrabbitmqctl stop 状态：\nrabbitmqctl status 防火墙之类的请自行处理（5672和15672端口），反正我是从来不开防火墙。\nWEB管理 开启web插件\nrabbitmq-plugins enable rabbitmq_management\r访问：http://127.0.0.1:15672/\n默认账号密码：guest guest（这个账号只允许本机访问）\n用户管理 查看所有用户\nrabbitmqctl list_users 添加一个用户\nrabbitmqctl add_user zhaobl 123456 配置权限\nrabbitmqctl set_permissions -p \u0026#34;/\u0026#34; zhaobl \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; 查看用户权限\nrabbitmqctl list_user_permissions zhaobl 设置tag\nrabbitmqctl set_user_tags zhaobl administrator 删除用户（安全起见，删除默认用户）\nrabbitmqctl delete_user guest 登陆 配置好用户之后重启一下rabbit\n然后就可以用新账号进行登陆\ndocker安装 udo docker pull rabbitmq:management sudo docker run -d --name rabbitmq -p 8671:5671 -p 8672:5672 -p 8369:4369 -p 28672:25672 -p 18671:15671 -p 15672:15672 rabbitmq:management ","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"e9504f9d560547fa195d09b36149fd10","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/rabbitmq%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/rabbitmq%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","section":"notes","summary":"原文地址：https://www.cnblogs.com/fengyumeng/p/11133924.html\n安装erlang 由于rabbitmq是基于erlang语言开发的，所以必须先安装erlang。\n安装依赖\nyum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel erlang官网：\nhttps://www.erlang.org/downloads\n下载（会比较慢，请耐心等待）\nwget http://erlang.org/download/otp_src_22.0.tar.gz 解压\ntar -zxvf otp_src_22.0.tar.gz 移走\nmv otp_src_22.0 /usr/local/ 切换目录\ncd /usr/local/otp_src_22.0/\r创建即将安装的目录\nmkdir ../erlang 配置安装路径\n./configure --prefix=/usr/local/erlang 如果遇到这个错 你就假装没看到\n安装\nmake install 查看一下是否安装成功\nll /usr/local/erlang/bin 添加环境变量\necho 'export PATH=$PATH:/usr/local/erlang/bin' \u0026gt;\u0026gt; /etc/profile\r刷新环境变量\nsource /etc/profile 甩一条命令\nerl 瞬间进入了一个未知的世界\n在里面输入halt().命令退出来（那个点号别忘记）\n安装RabbitMQ rabbitmq下载地址：\nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.15\n下载\nwget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.15/rabbitmq-server-generic-unix-3.7.15.tar.xz 由于是tar.xz格式的所以需要用到xz，没有的话就先安装\nyum install -y xz 第一次解压","tags":null,"title":"RabbitMQ安装配置","type":"docs"},{"authors":null,"categories":null,"content":"内置Predicates断言 原文地址：https://blog.csdn.net/weixin_43839681/article/details/106160813\n1 After 路由断言 After 路由断言只有一个ZonedDateTime生成的datetime参数，只有在这个事件之后的请求才能匹配上。\n Example 1. application.yml\n spring: cloud: gateway: routes: - id: after_route uri: https://example.org  predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] 12345678 https://example.org这个地址在美国Denver时间2017-01-20 17:42：00之后才能\n// 生成时间的代码 // demo 2020-05-06T19:16:43.338+08:00[Asia/Shanghai] System.out.println(ZonedDateTime.now().toString()); 123 2 Before 路由断言 Before 同样是一个时间断言，只不过是在配置的时间之前有效，过时之后失效。\n Example 2. application.yml\n spring: cloud: gateway: routes: - id: before_route uri: https://example.org  predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] 12345678 上面的链接地址在America/Denver时间2017-01-20 17:42::00之前有效\n3 Between 路由断言 Between 路由断言，时间类断言，在声明的时间内有效。并且第二个时间必须大于第一个时间。\n Example 3. application.yml\n spring: cloud: gateway: routes: - id: between_route uri: https://example.org  predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] 12345678 上面的链接在America/Denver时间2017-01 20日17时42-21日17时47分之间有效。\n4 Cookie 路由断言 Cookie 断言有两个参数，一个cookie 名称和一个java 正则表达式，这个断言匹配给定的cookie 名和值正则匹配的请求。\n Example 4. application.yml\n spring: cloud: gateway: routes: - id: cookie_route uri: https://example.org  predicates: - Cookie=chocolate, ch.p 12345678 上面的匹配那些请求中包含参数名为chocolate并且值匹配ch.p的请求。\n5 Header 路由断言 Header断言有两个参数，一个参数名，一个正则。只有当有这个参数并且值匹配正则的时候才能执行下去。\n Example 5. application.yml\n spring: cloud: gateway: routes: - id: header_route uri: https://example.org  predicates: - Header=X-Request-Id, \\d+ 12345678 这个路由规则匹配Header中包含X-Request-Id并且值为纯数字的请求。\n6 Host 路由断言 Host 路由断言接受一个正则域名列表，正则是用英文句号分割的Ant-Style(ant 风格？)正则表达式。\n Example 6. application.yml\n spring: cloud: gateway: routes: - id: host_route uri: https://example.org  predicates: - Host=**.somehost.org,**.anotherhost.org 12345678 这个路由匹配somehost.org anotherhost.org这两个域名下的所有请求。\n7 Method 路由断言 Method路由断言匹配一个或多个Http请求方式（GET POST PUT DELETE HEAD）.\n Example 7. application.yml\n spring: cloud: gateway: routes: - id: method_route uri: https://example.org  predicates: - Method=GET,POST 12345678 这个路由匹配所有的GET POST请求。\n8 Path 路径路由断言 Path路由断言接受两个参数：Spring PathMatcher 正则列表和一个名为 matchOptionalTrailingSeparator 的可选标志。\n Example 8. application.yml\n spring: cloud: gateway: routes: - id: path_route uri: https://example.org  predicates: - Path=/red/{segment},/blue/{segment} 12345678 如果请求路径为(例如: / red / 1或 / red / blue 或 / blue / green) ，则此路由匹配。 这个断言提取了URL中模板变量（像前面例子中声明的segment）组为key/value键值对放置在ServerWebExchange.getAttributes()中，并用已经声明的ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE来声明。这些内容可被GatewayFilter factories的一个名为get的方法很简单的去访问。\nMap\u0026lt;String, String\u0026gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange); String segment = uriVariables.get(\u0026#34;segment\u0026#34;); 123 9 Query 查询路由断言 Query路由断言有两个参数: 一个必传参数 and 和一个可选的正则表达式。\n Example 9. application.yml\n spring: cloud: gateway: routes: - id: query_route uri: https://example.org  predicates: - Query=green 12345678 如果一个请求中包含green的参数，则匹配成功。\n application.yml\n spring: cloud: gateway: routes: - id: query_route uri: https://example.org  predicates: - Query=red, gree. 12345678 如果一个请求中包含参数red并且值匹配·gree.·这个正则，那么路由匹配。比如：green和greet。\n10 RemoteAddr 远程地址路由断言 RemoteAddr路由断言接受一个来源地址的list，由IPv4或者IPv6组成，比如：192.168.0.1/16（其中192.168.0.1是IP地址，16是子网掩码）\n Example 10. application.yml\n spring: cloud: gateway: routes: - id: remoteaddr_route uri: https://example.org  predicates: - RemoteAddr=192.168.1.1/24 12345678 如果请求的远程地址是192.168.1.10，则此路由匹配。\n11. Weight 权重路由断言 权重路由断言接受两个参数：group分组和Weight权重。权重是按组计算的。\n Example 11. application.yml\n spring: cloud: gateway: routes: - id: weight_high uri: https://weighthigh.org  predicates: - Weight=group1, 8 - id: weight_low uri: https://weightlow.org  predicates: - Weight=group1, 2 123456789101112 这条路线将80% 的流量转发到 weighthigh. org，20% 的流量转发到 weighlow. org。\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"f836e55d367b677db3b80567c9f15faa","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E5%86%85%E7%BD%AEpredicates%E6%96%AD%E8%A8%80/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E5%86%85%E7%BD%AEpredicates%E6%96%AD%E8%A8%80/","section":"notes","summary":"内置Predicates断言 原文地址：https://blog.csdn.net/weixin_43839681/article/details/106160813\n1 After 路由断言 After 路由断言只有一个ZonedDateTime生成的datetime参数，只有在这个事件之后的请求才能匹配上。\n Example 1. application.yml\n spring: cloud: gateway: routes: - id: after_route uri: https://example.org  predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] 12345678 https://example.org这个地址在美国Denver时间2017-01-20 17:42：00之后才能\n// 生成时间的代码 // demo 2020-05-06T19:16:43.338+08:00[Asia/Shanghai] System.out.println(ZonedDateTime.now().toString()); 123 2 Before 路由断言 Before 同样是一个时间断言，只不过是在配置的时间之前有效，过时之后失效。\n Example 2. application.yml\n spring: cloud: gateway: routes: - id: before_route uri: https://example.org  predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] 12345678 上面的链接地址在America/Denver时间2017-01-20 17:42::00之前有效\n3 Between 路由断言 Between 路由断言，时间类断言，在声明的时间内有效。并且第二个时间必须大于第一个时间。\n Example 3. application.yml","tags":null,"title":"内置Predicates断言","type":"docs"},{"authors":null,"categories":null,"content":"提供端 在提供方cloud-hystrix-provider-payment8001写两个方法，一个正常访问一个超时访问\nPaymentService.java 正常访问\npublic String paymentInfo_OK(Integer id) { return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_OK,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~\u0026#34;; } 超时访问\npublic String paymentInfo_TimeOut(Integer id) { int timeNumber = 5; try { // 暂停5秒钟  TimeUnit.SECONDS.sleep(timeNumber); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_TimeOut,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~ 耗时(秒)\u0026#34; + timeNumber; } PaymentController.java package com.cloud.provider.payment.contrller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import com.cloud.provider.payment.service.PaymentService; import javax.annotation.Resource; /** * @author yzg * @create 2020/7/29 9:30 **/ @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; @Value(\u0026#34;${server.port}\u0026#34;) private String servicePort; /** * 正常访问 * * @param id * @return */ @GetMapping(\u0026#34;/payment/hystrix/ok/{id}\u0026#34;) public String paymentInfo_OK(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { String result = paymentService.paymentInfo_OK(id); return result; } /** * 超时访问 * * @param id * @return */ @GetMapping(\u0026#34;/payment/hystrix/timeout/{id}\u0026#34;) public String paymentInfo_TimeOut(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { String result = paymentService.paymentInfo_TimeOut(id); return result; } } ​\n8001自测 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-hystrix-provider-payment8001\n访问http://localhost:8001/payment/hystrix/ok/1 （正常请求）\n访问http://localhost:8001/payment/hystrix/timeout/1 （超时请求）\n正常请求访问正常，超时请求访问卡顿\n压力测试 这时请求一也卡顿了\n消费端 新建cloud-openfeign-hystrix-comsumer-order8011\nservice\npackage com.cloud.comsumer.order.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @Component @FeignClient(value = \u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;) public interface PaymentFeignService { @GetMapping(\u0026#34;/payment/hystrix/timeout/{id}\u0026#34;) public String paymentInfo_TimeOut(@PathVariable(\u0026#34;id\u0026#34;) Integer id); @GetMapping(\u0026#34;/payment/hystrix/ok/{id}\u0026#34;) public String paymentInfo_OK(@PathVariable(\u0026#34;id\u0026#34;) Integer id); } controller\npackage com.cloud.comsumer.order.contrller; import javax.annotation.Resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import com.cloud.comsumer.order.service.PaymentFeignService; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020/7/28 11:24 **/ @RestController @Slf4j public class OrderController { @Resource private PaymentFeignService paymentFeignService; /** * 正常访问 * * @param id * @return */ @GetMapping(\u0026#34;/consumer/payment/hystrix/ok/{id}\u0026#34;) public String paymentInfo_OK(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { return paymentFeignService.paymentInfo_OK(id); } /** * 超时访问 * * @param id * @return */ @GetMapping(\u0026#34;/consumer/payment/hystrix/timeout/{id}\u0026#34;) public String paymentInfo_TimeOut(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { return paymentFeignService.paymentInfo_TimeOut(id); } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-hystrix-provider-payment8001\n运行cloud-openfeign-hystrix-comsumer-order8011\n访问http://localhost:8011/consumer/payment/hystrix/ok/1 (正常请求) 访问http://localhost:8011/consumer/payment/hystrix/timeout/1 （超时请求） 正常请求访问正常，超时请求访问卡顿\n经过以上的压力测试\n正常请求访问卡顿甚至报超时错误，超时请求访问卡顿甚至报超时错误\n总结 Tomcat的默认的工作线程数被打满类，没有多余的线程来分解压力和处理\n","date":1595890800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595890800,"objectID":"13f23e4a8d354eaa12fc43a1203c5c64","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E5%8E%8B%E6%B5%8B%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","publishdate":"2020-07-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E5%8E%8B%E6%B5%8B%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","section":"notes","summary":"提供端 在提供方cloud-hystrix-provider-payment8001写两个方法，一个正常访问一个超时访问\nPaymentService.java 正常访问\npublic String paymentInfo_OK(Integer id) { return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_OK,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~\u0026#34;; } 超时访问\npublic String paymentInfo_TimeOut(Integer id) { int timeNumber = 5; try { // 暂停5秒钟  TimeUnit.SECONDS.sleep(timeNumber); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;线程池:\u0026#34; + Thread.currentThread().getName() + \u0026#34; paymentInfo_TimeOut,id:\u0026#34; + id + \u0026#34;\\t\u0026#34; + \u0026#34;O(∩_∩)O哈哈~ 耗时(秒)\u0026#34; + timeNumber; } PaymentController.java package com.cloud.provider.payment.contrller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.","tags":null,"title":"压测卡顿问题","type":"docs"},{"authors":null,"categories":null,"content":"官网：https://www.consul.io/ 中文文档：https://www.springcloud.cc/spring-cloud-consul.html\n什么是consul Consul是一个基于CP的轻量级分布式高可用的系统，提供服务发现、健康检查、K-V存储、多数据中心等功能，不需要再依赖其他组件(Zk、Eureka、Etcd等)。\n服务发现：Consul可以提供一个服务，比如api或者MySQL之类的，其他客户端可以使用Consul发现一个指定的服务提供者，并通过DNS和HTTP应用程序可以很容易的找到所依赖的服务。 健康检查：Consul客户端提供相应的健康检查接口，Consul服务端通过调用健康检查接口检测客户端是否正常 K-V存储：客户端可以使用Consul层级的Key/Value存储，比如动态配置,功能标记,协调,领袖选举等等 多数据中心：Consul支持开箱即用的多数据中心\n","date":1595808000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"cdf2b9ba91d72007a6dc1a14d557f559","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/consul/","publishdate":"2020-07-27T00:00:00Z","relpermalink":"/notes/cloud-study/consul/","section":"notes","summary":"官网：https://www.consul.io/ 中文文档：https://www.springcloud.cc/spring-cloud-consul.html\n什么是consul Consul是一个基于CP的轻量级分布式高可用的系统，提供服务发现、健康检查、K-V存储、多数据中心等功能，不需要再依赖其他组件(Zk、Eureka、Etcd等)。\n服务发现：Consul可以提供一个服务，比如api或者MySQL之类的，其他客户端可以使用Consul发现一个指定的服务提供者，并通过DNS和HTTP应用程序可以很容易的找到所依赖的服务。 健康检查：Consul客户端提供相应的健康检查接口，Consul服务端通过调用健康检查接口检测客户端是否正常 K-V存储：客户端可以使用Consul层级的Key/Value存储，比如动态配置,功能标记,协调,领袖选举等等 多数据中心：Consul支持开箱即用的多数据中心","tags":null,"title":"consul","type":"docs"},{"authors":null,"categories":null,"content":"","date":1595808000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"0435ad79c7413b8e9a40671dab003f0c","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/openfeign/","publishdate":"2020-07-27T00:00:00Z","relpermalink":"/notes/cloud-study/openfeign/","section":"notes","summary":"","tags":null,"title":"openfeign","type":"docs"},{"authors":null,"categories":null,"content":"","date":1595808000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"9e2e106ddda2b20b034ff5512737190f","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/ribbon/","publishdate":"2020-07-27T00:00:00Z","relpermalink":"/notes/cloud-study/ribbon/","section":"notes","summary":"","tags":null,"title":"Ribbon","type":"docs"},{"authors":null,"categories":null,"content":"   组件名 语言 CAP 服务健康检查 对外暴露接口     Eureka Java AP 可配支持 HTTP   Consul Go CP 支持 HTTP/DNS   Zookeeper Java CP 支持 客户端    CAP定理：指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\nCAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足 [1] 。\n因此在进行分布式架构设计时，必须做出取舍。当前一般是通过分布式缓存中各节点的最终一致性来提高系统的性能，通过使用多节点之间的数据异步复制技术来实现集群化的数据一致性。通常使用类似 memcached 之类的 NOSQL 作为实现手段。虽然 memcached 也可以是分布式集群环境的，但是对于一份数据来说，它总是存储在某一台 memcached 服务器上。如果发生网络故障或是服务器死机，则存储在这台服务器上的所有数据都将不可访问。由于数据是存储在内存中的，重启服务器，将导致数据全部丢失。当然也可以自己实现一套机制，用来在分布式 memcached 之间进行数据的同步和持久化，但是实现难度是非常大的\n","date":1595808000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"323b4be3bfe1a0922355e4d2be97b9cc","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9/","publishdate":"2020-07-27T00:00:00Z","relpermalink":"/notes/cloud-study/%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9/","section":"notes","summary":"组件名 语言 CAP 服务健康检查 对外暴露接口     Eureka Java AP 可配支持 HTTP   Consul Go CP 支持 HTTP/DNS   Zookeeper Java CP 支持 客户端    CAP定理：指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\nCAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足 [1] 。\n因此在进行分布式架构设计时，必须做出取舍。当前一般是通过分布式缓存中各节点的最终一致性来提高系统的性能，通过使用多节点之间的数据异步复制技术来实现集群化的数据一致性。通常使用类似 memcached 之类的 NOSQL 作为实现手段。虽然 memcached 也可以是分布式集群环境的，但是对于一份数据来说，它总是存储在某一台 memcached 服务器上。如果发生网络故障或是服务器死机，则存储在这台服务器上的所有数据都将不可访问。由于数据是存储在内存中的，重启服务器，将导致数据全部丢失。当然也可以自己实现一套机制，用来在分布式 memcached 之间进行数据的同步和持久化，但是实现难度是非常大的","tags":null,"title":"三个注册注册中心的异同点","type":"docs"},{"authors":null,"categories":null,"content":"启动zookeeper 新建项目 cloud-provider-payment8004\nPOM \u0026lt;!--SpringBoot整合Zookeeper客户端--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zookeeper-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!--先排除自带的zookeeper3.5.3--\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--添加zookeeper3.4.9版本--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\r# 8004表示注册到zookeeper服务器的支付服务提供者端口号\rport: 8004\rspring:\rapplication:\r# 服务别名---注册zookeeper到注册中心的名称\rname: cloud-provider-payment\rcloud:\rzookeeper:\r# 默认localhost:2181\rconnect-string: localhost:2181\r启动类 package com.cloud.provider.payment; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @SpringBootApplication public class PaymentMain8004 { public static void main(String[] args) { SpringApplication.run(PaymentMain8004.class, args); } } ","date":1595808000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"bb129640376681dcdc8adec63d5c9ea7","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/zookeeper/","publishdate":"2020-07-27T00:00:00Z","relpermalink":"/notes/cloud-study/zookeeper/","section":"notes","summary":"启动zookeeper 新建项目 cloud-provider-payment8004\nPOM \u0026lt;!--SpringBoot整合Zookeeper客户端--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zookeeper-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!--先排除自带的zookeeper3.5.3--\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--添加zookeeper3.4.9版本--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\r# 8004表示注册到zookeeper服务器的支付服务提供者端口号\rport: 8004\rspring:\rapplication:\r# 服务别名---注册zookeeper到注册中心的名称\rname: cloud-provider-payment\rcloud:\rzookeeper:\r# 默认localhost:2181\rconnect-string: localhost:2181\r启动类 package com.cloud.provider.payment; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient @SpringBootApplication public class PaymentMain8004 { public static void main(String[] args) { SpringApplication.run(PaymentMain8004.class, args); } } ","tags":null,"title":"服务注册zookerper","type":"docs"},{"authors":null,"categories":null,"content":"官网 https://www.sonarqube.org/\n\n nd Security  SonarQube empowers all developers to write cleaner and safer code. Join an Open Community of more than 200k dev teams.\nDownload\n","date":1594252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591660800,"objectID":"922362890d89d9712f4c69aac2553d63","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/sonarqube/","publishdate":"2020-07-09T00:00:00Z","relpermalink":"/notes/jenkins-study/sonarqube/","section":"notes","summary":"官网 https://www.sonarqube.org/\n\n nd Security  SonarQube empowers all developers to write cleaner and safer code. Join an Open Community of more than 200k dev teams.\nDownload","tags":null,"title":"sonarQube代码审查","type":"docs"},{"authors":null,"categories":null,"content":"触发远程构建 输入JENKINS_URL/view/all/job/cn-yzg-jfinaloa/build?token=TOKEN_NAME\n 或者 /buildWithParameters?token=TOKEN_NAME\n其他工程构建后触发 当frist-pro构建时触发\n定时触发 每30分钟构建一次\rH/30* * * *\r每2小时构建\rH H/2* * *\r每天8、12、22 一天构建3次\r0.8，12，22* * *\r每天中午12点定时构建一次\rH 12* * *\r每天下午18点定时构建一次\rH 18* * *\r在每小时的前半小时内的10分钟\rH(0-29)/10* * * *\r每两小时一次，每个工作日上午9点到下午5点\rH H(9-16)/2* *1-5\r轮询 SCM触发（不建议） 代码仓库发生变更时触发定时构建\n","date":1594249200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594249200,"objectID":"09180eb1bdbf3b9062b34a573fef0566","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E8%A7%A6%E5%8F%91%E5%99%A8/","publishdate":"2020-07-09T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E8%A7%A6%E5%8F%91%E5%99%A8/","section":"notes","summary":"触发远程构建 输入JENKINS_URL/view/all/job/cn-yzg-jfinaloa/build?token=TOKEN_NAME\n 或者 /buildWithParameters?token=TOKEN_NAME\n其他工程构建后触发 当frist-pro构建时触发\n定时触发 每30分钟构建一次\rH/30* * * *\r每2小时构建\rH H/2* * *\r每天8、12、22 一天构建3次\r0.8，12，22* * *\r每天中午12点定时构建一次\rH 12* * *\r每天下午18点定时构建一次\rH 18* * *\r在每小时的前半小时内的10分钟\rH(0-29)/10* * * *\r每两小时一次，每个工作日上午9点到下午5点\rH H(9-16)/2* *1-5\r轮询 SCM触发（不建议） 代码仓库发生变更时触发定时构建","tags":null,"title":"jenkins集成邮件","type":"docs"},{"authors":null,"categories":null,"content":"1.配置pipeline插件 2.编写Jenkinsfile 在项目的根目录下编写Jenkinsfile\npipeline { agent any stages { stage(\u0026#39;pull code\u0026#39;) { steps { checkout([$class: \u0026#39;GitSCM\u0026#39;, branches: [[name: \u0026#39;*/master\u0026#39;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \u0026#39;95f5cb07-e0fd-4186-9504-4d7e1d211d3b\u0026#39;, url: \u0026#39;https://gitee.com/MrPen/jfinaloa.git\u0026#39;]]]) } } stage(\u0026#39;package war\u0026#39;) { steps { sh \u0026#34;mvn clean package\u0026#34; } } stage(\u0026#39;publish\u0026#39;) { steps { deploy adapters: [tomcat8(credentialsId: \u0026#39;afc2e433-a99c-4070-b9d9-7125f4139bec\u0026#39;, path: \u0026#39;\u0026#39;, url: \u0026#39;http://203.176.95.155:8081/\u0026#39;)], contextPath: null, war: \u0026#39;target/*.war\u0026#39; } } } } 3.新建流水线项目 4.立即构建 ","date":1594162800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594162800,"objectID":"b9b99ccd3f8809eaef6bb117ca25807e","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/pipeline%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/","publishdate":"2020-07-08T00:00:00+01:00","relpermalink":"/notes/jenkins-study/pipeline%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/","section":"notes","summary":"1.配置pipeline插件 2.编写Jenkinsfile 在项目的根目录下编写Jenkinsfile\npipeline { agent any stages { stage(\u0026#39;pull code\u0026#39;) { steps { checkout([$class: \u0026#39;GitSCM\u0026#39;, branches: [[name: \u0026#39;*/master\u0026#39;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \u0026#39;95f5cb07-e0fd-4186-9504-4d7e1d211d3b\u0026#39;, url: \u0026#39;https://gitee.com/MrPen/jfinaloa.git\u0026#39;]]]) } } stage(\u0026#39;package war\u0026#39;) { steps { sh \u0026#34;mvn clean package\u0026#34; } } stage(\u0026#39;publish\u0026#39;) { steps { deploy adapters: [tomcat8(credentialsId: \u0026#39;afc2e433-a99c-4070-b9d9-7125f4139bec\u0026#39;, path: \u0026#39;\u0026#39;, url: \u0026#39;http://203.176.95.155:8081/\u0026#39;)], contextPath: null, war: \u0026#39;target/*.war\u0026#39; } } } } 3.新建流水线项目 4.立即构建 ","tags":null,"title":"Pipeline风格集成项目","type":"docs"},{"authors":null,"categories":null,"content":"安装插件 Role-based Authorization Strategy\n开启策略 系统管理\u0026ndash;\u0026raquo;全局安全配置\n配置权限 Global roles ：系统权限\nItem roles ：项目权限\n","date":1594076400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594076400,"objectID":"43e3d5a659ef07fb6118e86c5035ad95","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/","publishdate":"2020-07-07T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/","section":"notes","summary":"安装插件 Role-based Authorization Strategy\n开启策略 系统管理\u0026ndash;\u0026raquo;全局安全配置\n配置权限 Global roles ：系统权限\nItem roles ：项目权限","tags":null,"title":"jenkins用户权限","type":"docs"},{"authors":null,"categories":null,"content":"安装git yum install git -y 安装maven 下载maven https://maven.apache.org/download.cgi 将tar包移动到服务器 解压\ntar -xzf apache-maven-3.6.3-bin.tar.gz 配置环境变量\nvim /etc/profile\r追加以下内容\nexport JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk\rexport MAVEN_HOME=/opt/maven\rexport PATH=${JAVA_HOME}/bin:${MAVEN_HOME}/bin\r重载环境变量\nsource /etc/profile 测试\nmvn -v\r出现以下内容安装成功\nApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)\rMaven home: /opt/maven\rJava version: 1.8.0_252, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64/jre\rDefault locale: en_US, platform encoding: UTF-8\rOS name: \u0026quot;linux\u0026quot;, version: \u0026quot;3.10.0-327.el7.x86_64\u0026quot;, arch: \u0026quot;amd64\u0026quot;, family: \u0026quot;unix\u0026quot;\r配置settings.xml mkdir /root/repo\rvim /opt/maven/conf/settings.xml 配置本地仓库\n \u0026lt;localRepository\u0026gt;/root/repo\u0026lt;/localRepository\u0026gt;\r配置阿里云镜像\n \u0026lt;mirror\u0026gt;\r\u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt;\r\u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt;\r\u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public\u0026lt;/url\u0026gt;\r\u0026lt;/mirror\u0026gt; jenkins配置jdk和maven 系统设置\u0026ndash;\u0026raquo;系统配置\u0026ndash;\u0026raquo;全局属性环境变量\n分别配置JAVA_HOME，M2_HOME，PATH+EXTRA\n","date":1594076400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594076400,"objectID":"964744d031227d3bfd836018fa36164e","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E9%85%8D%E7%BD%AEjdkmaven/","publishdate":"2020-07-07T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E9%85%8D%E7%BD%AEjdkmaven/","section":"notes","summary":"安装git yum install git -y 安装maven 下载maven https://maven.apache.org/download.cgi 将tar包移动到服务器 解压\ntar -xzf apache-maven-3.6.3-bin.tar.gz 配置环境变量\nvim /etc/profile\r追加以下内容\nexport JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk\rexport MAVEN_HOME=/opt/maven\rexport PATH=${JAVA_HOME}/bin:${MAVEN_HOME}/bin\r重载环境变量\nsource /etc/profile 测试\nmvn -v\r出现以下内容安装成功\nApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)\rMaven home: /opt/maven\rJava version: 1.8.0_252, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64/jre\rDefault locale: en_US, platform encoding: UTF-8\rOS name: \u0026quot;linux\u0026quot;, version: \u0026quot;3.10.0-327.el7.x86_64\u0026quot;, arch: \u0026quot;amd64\u0026quot;, family: \u0026quot;unix\u0026quot;\r配置settings.xml mkdir /root/repo\rvim /opt/maven/conf/settings.xml 配置本地仓库\n \u0026lt;localRepository\u0026gt;/root/repo\u0026lt;/localRepository\u0026gt;\r配置阿里云镜像\n \u0026lt;mirror\u0026gt;\r\u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt;\r\u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt;\r\u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;http://maven.","tags":null,"title":"jenkins配置jdk,maven","type":"docs"},{"authors":null,"categories":null,"content":"Compose 简介 Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\nCompose 使用的三个步骤：\n 使用 Dockerfile 定义应用程序的环境。 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。 最后，执行 docker-compose up 命令来启动并运行整个应用程序。  ","date":1593388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593388800,"objectID":"146bcb6ef9cc129d681d19c6b74aa1e8","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dockercompose/","publishdate":"2020-06-29T00:00:00Z","relpermalink":"/notes/docker-study/dockercompose/","section":"notes","summary":"Compose 简介 Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\nCompose 使用的三个步骤：\n 使用 Dockerfile 定义应用程序的环境。 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。 最后，执行 docker-compose up 命令来启动并运行整个应用程序。  ","tags":null,"title":"docker 三剑客 Compose","type":"docs"},{"authors":null,"categories":null,"content":"Docker 私有仓库 有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。\n本节介绍如何使用本地仓库。\ndocker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。\n","date":1593388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593388800,"objectID":"f1a56871e07ba49745f0d5c892306cef","permalink":"https://academia-hugo.netlify.com/notes/docker-study/docker%E7%A7%81%E6%9C%89%E5%BA%93/","publishdate":"2020-06-29T00:00:00Z","relpermalink":"/notes/docker-study/docker%E7%A7%81%E6%9C%89%E5%BA%93/","section":"notes","summary":"Docker 私有仓库 有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。\n本节介绍如何使用本地仓库。\ndocker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。","tags":null,"title":"docker 私有库","type":"docs"},{"authors":null,"categories":null,"content":"POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 7001\reureka:\rinstance:\rhostname: localhost\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\r启动类 package com.yzg.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; /** * eureka服务端启动类 * * @author yangzhangguan * @create 2020/7/20 23:32 **/ @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class); } } ","date":1593388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595203200,"objectID":"c0f94b4e02460d24d9c3a49a505c9676","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/eureka/","publishdate":"2020-06-29T00:00:00Z","relpermalink":"/notes/cloud-study/eureka/","section":"notes","summary":"POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml server:\rport: 7001\reureka:\rinstance:\rhostname: localhost\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\r启动类 package com.yzg.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; /** * eureka服务端启动类 * * @author yangzhangguan * @create 2020/7/20 23:32 **/ @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class); } } ","tags":null,"title":"eureka","type":"docs"},{"authors":null,"categories":null,"content":"下载 下载地址 https://releases.hashicorp.com/consul/1.8.0/consul_1.8.0_linux_amd64.zip\n安装 unzip consul_1.8.0_linux_amd64.zip 将文件迁移到/usr/bin/\nmv consul /usr/bin 运行 consul agent -dev -client=0.0.0.0 -ui\u0026amp; 开发8500端口\nfirewall-cmd --zone=public --add-port=8500/tcp --permanent firewall-cmd --reload ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"7448749abc2de7a4b3d9275b3d41050c","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/consul%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/consul%E5%AE%89%E8%A3%85/","section":"notes","summary":"下载 下载地址 https://releases.hashicorp.com/consul/1.8.0/consul_1.8.0_linux_amd64.zip\n安装 unzip consul_1.8.0_linux_amd64.zip 将文件迁移到/usr/bin/\nmv consul /usr/bin 运行 consul agent -dev -client=0.0.0.0 -ui\u0026amp; 开发8500端口\nfirewall-cmd --zone=public --add-port=8500/tcp --permanent firewall-cmd --reload ","tags":null,"title":"consul安装","type":"docs"},{"authors":null,"categories":null,"content":"术语   服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。\n  项目 (project)：由一组关联的应用容器组成的一个完整业务单元。\n  一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。\ndocker Compose启动tomcat 在 /usr/local/docker/tomcat下创建一个docker-compose.yml\nversion: '3'\rservices:\rtomcat:\rrestart: always\rimage: tomcat\rcontainer_name: tomcat\rports:\r- 18080:8080\r运行 compose 项目 在docker-compose.yml所在的目录下执行\ndocker-compose up 后台运行\ndocker-compose up -d ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"b3219bfc223db2f908f2a16573881998","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dockercompose%E4%BD%BF%E7%94%A8/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/dockercompose%E4%BD%BF%E7%94%A8/","section":"notes","summary":"术语   服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。\n  项目 (project)：由一组关联的应用容器组成的一个完整业务单元。\n  一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。\ndocker Compose启动tomcat 在 /usr/local/docker/tomcat下创建一个docker-compose.yml\nversion: '3'\rservices:\rtomcat:\rrestart: always\rimage: tomcat\rcontainer_name: tomcat\rports:\r- 18080:8080\r运行 compose 项目 在docker-compose.yml所在的目录下执行\ndocker-compose up 后台运行\ndocker-compose up -d ","tags":null,"title":"docker Compose使用","type":"docs"},{"authors":null,"categories":null,"content":"Compose 安装 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。\n运行以下命令以下载 Docker Compose 的当前稳定版本：\nsudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 要安装其他版本的 Compose，请替换 1.24.1。\n高速安装 Docker Compose 存放在Git Hub，不太稳定。 你可以也通过执行下面的命令，高速安装Docker Compose。\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.26.0/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose 授权 chmod +x /usr/local/bin/docker-compose 验证 docker-compose --version 安装成功！！！\n卸载 sudo rm /usr/local/bin/docker-compose ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"e507e1b138585b4df828203980dfd897","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dockercompose%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/dockercompose%E5%AE%89%E8%A3%85/","section":"notes","summary":"Compose 安装 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。\n运行以下命令以下载 Docker Compose 的当前稳定版本：\nsudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose 要安装其他版本的 Compose，请替换 1.24.1。\n高速安装 Docker Compose 存放在Git Hub，不太稳定。 你可以也通过执行下面的命令，高速安装Docker Compose。\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.26.0/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose 授权 chmod +x /usr/local/bin/docker-compose 验证 docker-compose --version 安装成功！！！\n卸载 sudo rm /usr/local/bin/docker-compose ","tags":null,"title":"docker Compose安装","type":"docs"},{"authors":null,"categories":null,"content":"docker Compose 部署RuoYi项目 RuoYi ， MYSQL ， docker Compose， dockerfile\n项目gitee地址.\n根据 ruoyi官方.文档将RuoYi项目打包成jar\n打jar包 bin/package.bat 在项目的目录下执行 然后会在项目下生成 target文件夹包含 war 或jar （多模块生成在ruoyi-admin）\n1、jar部署方式 使用命令行执行：java –jar ruoyi.jar 或者执行脚本：bin/run.bat\n2、war部署方式 pom.xml packaging修改为war 放入tomcat服务器webapps\n修改配置文件 application-druid.yml\nspring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.cj.jdbc.Driver druid: # 主库数据源 mysqldbserver必须与 container_name一致 master: url: jdbc:mysql://mysqldbserver:3306/ry?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=true\u0026amp;serverTimezone=GMT%2B8 username: root password: root 编写app-dockerfile FROMjava:8MAINTAINERmrpenADD ./ruoyi/ruoyi-admin.jar app.jarEXPOSE8081ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;,\u0026#34;app.jar\u0026#34;] FROM: 基础镜像,通过jdk8镜像开始 MAINTAINER: 维护者 ADD: 复制jar包到镜像内,名字为app.jar EXPOSE: 声明端口 ENTRYPOINT: docker启动时,运行的命令.这里就是容器运行就启动jar服务  编写mysql-dockerfile FROMmysql:5.7MAINTAINERmrpen编写docker-compose.yml version : \u0026#39;3\u0026#39; services: mysqldbserver: container_name: mysqldbserver image: mysql:5.7 build: context: . dockerfile: mysql-dockerfile ports: - \u0026#34;3306:3306\u0026#34; volumes: - ./mysql/conf:/etc/mysql/conf.d - ./mysql/logs:/logs - ./mysql/data:/var/lib/mysql command: [ \u0026#39;mysqld\u0026#39;, \u0026#39;--innodb-buffer-pool-size=80M\u0026#39;, \u0026#39;--character-set-server=utf8\u0026#39;, \u0026#39;--collation-server=utf8_general_ci\u0026#39;, \u0026#39;--default-time-zone=+8:00\u0026#39;, \u0026#39;--lower-case-table-names=1\u0026#39; ] environment: MYSQL_DATABASE: ry MYSQL_ROOT_PASSWORD: root ryappserver: container_name: ryappserver build: context: . dockerfile: app-dockerfile ports: - \u0026#34;8081:8081\u0026#34; volumes: - ./uploadPath:/home/ruoyi/uploadPath depends_on: - mysqldbserver links: - mysqldbserver 启动 docker-compose ps -d 这个时候还是访问不了的，因为我们的数据库还没导入\n将ry.sql导入后\n重新启动ryappserver服务\ndocker-compose restart ryappserver 查看ryappserver的容器ID docker ps 查看容器日志 docker logs -f 2559d6cdadf7 运行成功 ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"59b877b8ac3a76769bb271e0fb58d332","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dockercompose%E5%AE%9E%E6%88%98/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/dockercompose%E5%AE%9E%E6%88%98/","section":"notes","summary":"docker Compose 部署RuoYi项目 RuoYi ， MYSQL ， docker Compose， dockerfile\n项目gitee地址.\n根据 ruoyi官方.文档将RuoYi项目打包成jar\n打jar包 bin/package.bat 在项目的目录下执行 然后会在项目下生成 target文件夹包含 war 或jar （多模块生成在ruoyi-admin）\n1、jar部署方式 使用命令行执行：java –jar ruoyi.jar 或者执行脚本：bin/run.bat\n2、war部署方式 pom.xml packaging修改为war 放入tomcat服务器webapps\n修改配置文件 application-druid.yml\nspring: datasource: type: com.alibaba.druid.pool.DruidDataSource driverClassName: com.mysql.cj.jdbc.Driver druid: # 主库数据源 mysqldbserver必须与 container_name一致 master: url: jdbc:mysql://mysqldbserver:3306/ry?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=true\u0026amp;serverTimezone=GMT%2B8 username: root password: root 编写app-dockerfile FROMjava:8MAINTAINERmrpenADD ./ruoyi/ruoyi-admin.jar app.jarEXPOSE8081ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;,\u0026#34;app.jar\u0026#34;] FROM: 基础镜像,通过jdk8镜像开始 MAINTAINER: 维护者 ADD: 复制jar包到镜像内,名字为app.jar EXPOSE: 声明端口 ENTRYPOINT: docker启动时,运行的命令.这里就是容器运行就启动jar服务  编写mysql-dockerfile FROMmysql:5.7MAINTAINERmrpen编写docker-compose.yml version : \u0026#39;3\u0026#39; services: mysqldbserver: container_name: mysqldbserver image: mysql:5.","tags":null,"title":"dockerCompose实战","type":"docs"},{"authors":null,"categories":null,"content":"修改主机映射文件(模拟两台主机） 文件地址C:\\Windows\\System32\\drivers\\etc\\hosts\n127.0.0.1 eureka7001.com\r127.0.0.1 eureka7002.com\r修改配置文件 cloud-eureka-server7001项目\nserver:\rport: 7001\reureka:\rinstance:\rhostname: eureka7001.com\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://eureka7002.com:7002/eureka/\rcloud-eureka-server7002项目\nserver:\rport: 7002\reureka:\rinstance:\rhostname: eureka7002.com\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://eureka7001.com:7001/eureka/\r","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"8af246369a9ede4b22689c502eac5050","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/eureka-server%E9%9B%86%E7%BE%A4/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/eureka-server%E9%9B%86%E7%BE%A4/","section":"notes","summary":"修改主机映射文件(模拟两台主机） 文件地址C:\\Windows\\System32\\drivers\\etc\\hosts\n127.0.0.1 eureka7001.com\r127.0.0.1 eureka7002.com\r修改配置文件 cloud-eureka-server7001项目\nserver:\rport: 7001\reureka:\rinstance:\rhostname: eureka7001.com\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://eureka7002.com:7002/eureka/\rcloud-eureka-server7002项目\nserver:\rport: 7002\reureka:\rinstance:\rhostname: eureka7002.com\rclient:\r#false表示不向注册中心注册自己\rregister-with-eureka: false\r#false表示自己端就是注册中心\rfetch-registry: false\r#设置与eureka server交互的地址，查询服务和注册服务都是这个地址\rservice-url:\rdefaultZone: http://eureka7001.com:7001/eureka/\r","tags":null,"title":"eureka-server集群","type":"docs"},{"authors":null,"categories":null,"content":"GitLab\n新建用户 新建项目 SSH拉取和推送项目 进入Gti的安装目录下的的usr\\bin下，默认在C:\\Program Files\\Git\\usr\\bin 进入cmd，输入以下命令（1785868089@qq.com可以改成你的邮箱）\nssh-keygen -t rsa -C \u0026#34;1785868089@qq.com\u0026#34; 设置SSH密钥 复制id_rsa.pub文件下的内容 配置TortoiseGit\n采用SSH克隆\n不需要密码拉取成功！！！！\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"3cbf575bfd2893f7aa2a55ad9b29c760","permalink":"https://academia-hugo.netlify.com/notes/paas-study/gitlab%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/paas-study/gitlab%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","section":"notes","summary":"GitLab\n新建用户 新建项目 SSH拉取和推送项目 进入Gti的安装目录下的的usr\\bin下，默认在C:\\Program Files\\Git\\usr\\bin 进入cmd，输入以下命令（1785868089@qq.com可以改成你的邮箱）\nssh-keygen -t rsa -C \u0026#34;1785868089@qq.com\u0026#34; 设置SSH密钥 复制id_rsa.pub文件下的内容 配置TortoiseGit\n采用SSH克隆\n不需要密码拉取成功！！！！","tags":null,"title":"GitLab基本设置","type":"docs"},{"authors":null,"categories":null,"content":"GitLab中文版安装 GitLab ,docker-compose\ndockerHub 中文版镜像地址\n拉取镜像 docker pull twang2218/gitlab-ce-zh 编写docker-compose.yml version: \u0026#39;3\u0026#39; services: gitlab: image: \u0026#39;docker.io/twang2218/gitlab-ce-zh:latest\u0026#39; restart: unless-stopped hostname: \u0026#39;203.176.95.155:8081\u0026#39; environment: TZ: \u0026#39;mrpen/Nanning\u0026#39; GITLAB_OMNIBUS_CONFIG: | external_url \u0026#39;http://203.176.95.155:8088\u0026#39; gitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 2222 gitlab_rails[\u0026#39;port\u0026#39;] = 8888 gitlab_rails[\u0026#39;listen_port\u0026#39;] = 8088 ports: - \u0026#39;8088:8088\u0026#39; - \u0026#39;8443:443\u0026#39; - \u0026#39;2222:22\u0026#39; volumes: - ./config:/etc/gitlab - ./config:/var/opt/gitlab - ./log:/var/log/gitlab 输入http://你的主机IP:8088/访问\n修改密码后登陆，账号是root\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"1ac700d1db00f60dcd3b0a724fad36e8","permalink":"https://academia-hugo.netlify.com/notes/paas-study/gitlab%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/paas-study/gitlab%E5%AE%89%E8%A3%85/","section":"notes","summary":"GitLab中文版安装 GitLab ,docker-compose\ndockerHub 中文版镜像地址\n拉取镜像 docker pull twang2218/gitlab-ce-zh 编写docker-compose.yml version: \u0026#39;3\u0026#39; services: gitlab: image: \u0026#39;docker.io/twang2218/gitlab-ce-zh:latest\u0026#39; restart: unless-stopped hostname: \u0026#39;203.176.95.155:8081\u0026#39; environment: TZ: \u0026#39;mrpen/Nanning\u0026#39; GITLAB_OMNIBUS_CONFIG: | external_url \u0026#39;http://203.176.95.155:8088\u0026#39; gitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 2222 gitlab_rails[\u0026#39;port\u0026#39;] = 8888 gitlab_rails[\u0026#39;listen_port\u0026#39;] = 8088 ports: - \u0026#39;8088:8088\u0026#39; - \u0026#39;8443:443\u0026#39; - \u0026#39;2222:22\u0026#39; volumes: - ./config:/etc/gitlab - ./config:/var/opt/gitlab - ./log:/var/log/gitlab 输入http://你的主机IP:8088/访问\n修改密码后登陆，账号是root","tags":null,"title":"GitLab安装","type":"docs"},{"authors":null,"categories":null,"content":"前提条件 开启两台机器 机器A: (docker私有库) 机器B: (外部访问)\n注意事项 如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。\n这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。\n机器B 添加http信任\n编辑 /etc/docker/daemon.json 文件\nvim /etc/docker/daemon.json\r内容如下\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://registry.docker-cn.com\u0026#34; ], \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;机器A的IP:18080\u0026#34; ] } 重启docker\nsystemctl daemon-reload systemctl restart docker.service 登录 docker login [机器A的ip]:[docker私有库端口号]\r镜像推送 机器A 新建一个私有项目 机器B 在项目中标记镜像\ndocker tag tomcat:latest [机器A的ip]:18080/repo-test/mytomcat 推送镜像到当前项目\ndocker push [机器A的ip]:18080/repo-test/mytomcat 镜像拉取 为了避免混淆先把本地的镜像全部删了\ndocker rmi $(docker images -a) 先确认本地没有镜像\ndocker pull [机器A的ip]:18080/repo-test/mytomcat ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"046f407d255bdcf0cc62fc076083a0a8","permalink":"https://academia-hugo.netlify.com/notes/docker-study/harbor%E6%93%8D%E4%BD%9C/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/harbor%E6%93%8D%E4%BD%9C/","section":"notes","summary":"前提条件 开启两台机器 机器A: (docker私有库) 机器B: (外部访问)\n注意事项 如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。\n这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。\n机器B 添加http信任\n编辑 /etc/docker/daemon.json 文件\nvim /etc/docker/daemon.json\r内容如下\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://registry.docker-cn.com\u0026#34; ], \u0026#34;insecure-registries\u0026#34;: [ \u0026#34;机器A的IP:18080\u0026#34; ] } 重启docker\nsystemctl daemon-reload systemctl restart docker.service 登录 docker login [机器A的ip]:[docker私有库端口号]\r镜像推送 机器A 新建一个私有项目 机器B 在项目中标记镜像\ndocker tag tomcat:latest [机器A的ip]:18080/repo-test/mytomcat 推送镜像到当前项目\ndocker push [机器A的ip]:18080/repo-test/mytomcat 镜像拉取 为了避免混淆先把本地的镜像全部删了\ndocker rmi $(docker images -a) 先确认本地没有镜像","tags":null,"title":"Harbor（上传、搜索、下载镜像）","type":"docs"},{"authors":null,"categories":null,"content":"给工程添加devtools \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 给父类工程添加插件 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;addResources\u0026gt;true\u0026lt;/addResources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 开启自动编译 更新配置 输入快捷键ctrl+shift+Alt+/\n重启idea ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"bc86438686c4136431916b43827090e2","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/idea%E7%83%AD%E9%83%A8%E7%BD%B2/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/idea%E7%83%AD%E9%83%A8%E7%BD%B2/","section":"notes","summary":"给工程添加devtools \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 给父类工程添加插件 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;addResources\u0026gt;true\u0026lt;/addResources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 开启自动编译 更新配置 输入快捷键ctrl+shift+Alt+/\n重启idea ","tags":null,"title":"idea热部署","type":"docs"},{"authors":null,"categories":null,"content":"jenkins安装 jenkins\n官方网址：https://pkg.jenkins.io/redhat-stable/\n上官网下载rpm包\n安装 rpm -ivh jenkins-2.235.1-1.1.noarch.rpm 修改配置 vim /etc/sysconfig/jenkins 修改端口号为8888\nJENKINS_PORT=\u0026quot;8888\u0026rdquo;\n修改用户名\u0026quot;root\u0026rdquo;\nJENKINS_USER=\u0026quot;root\u0026rdquo;\n启动jenkins systemctl start jenkins 开放8888端口\nfirewall-cmd --zone=public --add-port=8888/tcp --permanent firewall-cmd --reload 输入http://你的主机IP:8888/访问\n查看密码\ncat /var/lib/jenkins/secrets/initialAdminPassword- 跳过插件安装\n使用清华源加速插件安装 修改 Update Site\nManage Jenkins -\u0026raquo;Manager plugin-\u0026raquo;Advanced\n修改为\nhttp://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 替换default.json的下载路径\ncd /var/lib/jenkins/updates sed -i 's/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g' default.json \u0026amp;\u0026amp; sed -i 's/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g' default.json\r浏览器输入 http://你的主机名:8888/restart 重启\ndocker docker run -u root --rm -d -p 8888:8080 -p 50000:50000 -v jenkins-data:/var/jenkins_home jenkins/jenkins\r卸载 find / -iname jenkins | xargs -n 1000 rm -rf\r","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"64ccdf632170a6e88c6080c7a1f8c60f","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E5%AE%89%E8%A3%85/","section":"notes","summary":"jenkins安装 jenkins\n官方网址：https://pkg.jenkins.io/redhat-stable/\n上官网下载rpm包\n安装 rpm -ivh jenkins-2.235.1-1.1.noarch.rpm 修改配置 vim /etc/sysconfig/jenkins 修改端口号为8888\nJENKINS_PORT=\u0026quot;8888\u0026rdquo;\n修改用户名\u0026quot;root\u0026rdquo;\nJENKINS_USER=\u0026quot;root\u0026rdquo;\n启动jenkins systemctl start jenkins 开放8888端口\nfirewall-cmd --zone=public --add-port=8888/tcp --permanent firewall-cmd --reload 输入http://你的主机IP:8888/访问\n查看密码\ncat /var/lib/jenkins/secrets/initialAdminPassword- 跳过插件安装\n使用清华源加速插件安装 修改 Update Site\nManage Jenkins -\u0026raquo;Manager plugin-\u0026raquo;Advanced\n修改为\nhttp://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 替换default.json的下载路径\ncd /var/lib/jenkins/updates sed -i 's/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g' default.json \u0026amp;\u0026amp; sed -i 's/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g' default.json\r浏览器输入 http://你的主机名:8888/restart 重启\ndocker docker run -u root --rm -d -p 8888:8080 -p 50000:50000 -v jenkins-data:/var/jenkins_home jenkins/jenkins\r卸载 find / -iname jenkins | xargs -n 1000 rm -rf\r","tags":null,"title":"jenkins安装","type":"docs"},{"authors":null,"categories":null,"content":"前提条件 开启邮箱服务器的SMTP功能\n安装插件 Email Extension Template\n配置 测试成功 添加邮件模板 项目根目录下添加邮件模板email.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;${ENV, var=\u0026#34;JOB_NAME\u0026#34;}-第${BUILD_NUMBER}次构建日志\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body leftmargin=\u0026#34;8\u0026#34; marginwidth=\u0026#34;0\u0026#34; topmargin=\u0026#34;8\u0026#34; marginheight=\u0026#34;4\u0026#34; offset=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;table width=\u0026#34;95%\u0026#34; cellpadding=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34; style=\u0026#34;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;(本邮件是程序自动下发的，请勿回复！)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#0000FF\u0026#34;\u0026gt;构建结果 - ${BUILD_STATUS}\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;构建信息\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目名称\u0026amp;nbsp;：\u0026amp;nbsp;${PROJECT_NAME}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建编号\u0026amp;nbsp;：\u0026amp;nbsp;第${BUILD_NUMBER}次构建\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;触发原因：\u0026amp;nbsp;${CAUSE}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建日志：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${BUILD_URL}console\u0026#34;\u0026gt;${BUILD_URL}console\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建\u0026amp;nbsp;\u0026amp;nbsp;Url\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${BUILD_URL}\u0026#34;\u0026gt;${BUILD_URL}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;工作目录\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${PROJECT_URL}ws\u0026#34;\u0026gt;${PROJECT_URL}ws\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目\u0026amp;nbsp;\u0026amp;nbsp;Url\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${PROJECT_URL}\u0026#34;\u0026gt;${PROJECT_URL}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;Changes Since Last Successful Build:\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;历史变更记录 : \u0026lt;a href=\u0026#34;${PROJECT_URL}changes\u0026#34;\u0026gt;${PROJECT_URL}changes\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;b\u0026gt;Failed Test Results\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;pre style=\u0026#34;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\u0026#34;\u0026gt;$FAILED_TESTS\u0026lt;/pre\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;构建日志 (最后 100行):\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Test Logs (if test has ran): \u0026lt;a href=\u0026#34;${PROJECT_URL}ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip\u0026#34;\u0026gt;${PROJECT_URL}/ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip\u0026lt;/a\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;textarea cols=\u0026#34;80\u0026#34; rows=\u0026#34;30\u0026#34; readonly=\u0026#34;readonly\u0026#34; style=\u0026#34;font-family: Courier New\u0026#34;\u0026gt;${BUILD_LOG, maxLines=100}\u0026lt;/textarea\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修改jenkinsfile post { always { emailext( subject: \u0026#39;构建通知: ${PROJECT_NAME} - Build # ${BUILD_NUMBER} - ${BUILD_STATUS)!\u0026#39;, body: \u0026#39;${FILE,path=\u0026#34;email.html\u0026#34;}\u0026#39;, to: \u0026#39;1785868089@qq.com\u0026#39; ) } } 立即构建\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"35547442e33a9f3528d376258a1e576a","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E9%9B%86%E6%88%90%E9%82%AE%E4%BB%B6/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E9%9B%86%E6%88%90%E9%82%AE%E4%BB%B6/","section":"notes","summary":"前提条件 开启邮箱服务器的SMTP功能\n安装插件 Email Extension Template\n配置 测试成功 添加邮件模板 项目根目录下添加邮件模板email.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;${ENV, var=\u0026#34;JOB_NAME\u0026#34;}-第${BUILD_NUMBER}次构建日志\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body leftmargin=\u0026#34;8\u0026#34; marginwidth=\u0026#34;0\u0026#34; topmargin=\u0026#34;8\u0026#34; marginheight=\u0026#34;4\u0026#34; offset=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;table width=\u0026#34;95%\u0026#34; cellpadding=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34; style=\u0026#34;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;(本邮件是程序自动下发的，请勿回复！)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;h2\u0026gt;\u0026lt;font color=\u0026#34;#0000FF\u0026#34;\u0026gt;构建结果 - ${BUILD_STATUS}\u0026lt;/font\u0026gt;\u0026lt;/h2\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;构建信息\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;项目名称\u0026amp;nbsp;：\u0026amp;nbsp;${PROJECT_NAME}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建编号\u0026amp;nbsp;：\u0026amp;nbsp;第${BUILD_NUMBER}次构建\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;触发原因：\u0026amp;nbsp;${CAUSE}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建日志：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${BUILD_URL}console\u0026#34;\u0026gt;${BUILD_URL}console\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;构建\u0026amp;nbsp;\u0026amp;nbsp;Url\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${BUILD_URL}\u0026#34;\u0026gt;${BUILD_URL}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;工作目录\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${PROJECT_URL}ws\u0026#34;\u0026gt;${PROJECT_URL}ws\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;项目\u0026amp;nbsp;\u0026amp;nbsp;Url\u0026amp;nbsp;：\u0026amp;nbsp;\u0026lt;a href=\u0026#34;${PROJECT_URL}\u0026#34;\u0026gt;${PROJECT_URL}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;Changes Since Last Successful Build:\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;历史变更记录 : \u0026lt;a href=\u0026#34;${PROJECT_URL}changes\u0026#34;\u0026gt;${PROJECT_URL}changes\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;b\u0026gt;Failed Test Results\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;pre style=\u0026#34;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif\u0026#34;\u0026gt;$FAILED_TESTS\u0026lt;/pre\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;b\u0026gt;\u0026lt;font color=\u0026#34;#0B610B\u0026#34;\u0026gt;构建日志 (最后 100行):\u0026lt;/font\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;hr size=\u0026#34;2\u0026#34; width=\u0026#34;100%\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!","tags":null,"title":"jenkins触发器","type":"docs"},{"authors":null,"categories":null,"content":"安装插件 安装SonarQube Scanner插件\n添加凭证 安装SonarQube Scanner 配置SonarQube servers 系统配置\u0026ndash;\u0026raquo;系统配置\u0026ndash;\u0026raquo;SonarQube servers 自由风格项目配置 流水线项目配置 在项目根目录下创建sonar-project.properties文件 sonar-project.properties\nsonar.projectKey=com-yzg-jfinaloa-pipeline sonar.projectName=com-yzg-jfinaloa-pipeline sonar.projectVersion=1.0 sonar.sources=src/main/java/com/pointlion/ sonar.exclusions=**/test/**,**/target/** sonar.java.sources=1.8 sonar.java.target=1.8 sonar.sourceEncoding=UTF-8 jenkinsfile加入以下配置\nstage(\u0026#39;code checking\u0026#39;) { steps { script { //引入sonarqubeScanner工具 scannerHome= tool \u0026#39;SonarQube\u0026#39; } withSonarQubeEnv(\u0026#39;SonarQube\u0026#39;) { //引入SonarQube的服务器环境 sh \u0026#34;${scannerHome}/bin/sonar-scanner\u0026#34; } } } ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"b27b6c69ca5ba8ef5020e788d9ab116e","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/jenkins%E9%9B%86%E6%88%90sonarqube/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/jenkins-study/jenkins%E9%9B%86%E6%88%90sonarqube/","section":"notes","summary":"安装插件 安装SonarQube Scanner插件\n添加凭证 安装SonarQube Scanner 配置SonarQube servers 系统配置\u0026ndash;\u0026raquo;系统配置\u0026ndash;\u0026raquo;SonarQube servers 自由风格项目配置 流水线项目配置 在项目根目录下创建sonar-project.properties文件 sonar-project.properties\nsonar.projectKey=com-yzg-jfinaloa-pipeline sonar.projectName=com-yzg-jfinaloa-pipeline sonar.projectVersion=1.0 sonar.sources=src/main/java/com/pointlion/ sonar.exclusions=**/test/**,**/target/** sonar.java.sources=1.8 sonar.java.target=1.8 sonar.sourceEncoding=UTF-8 jenkinsfile加入以下配置\nstage(\u0026#39;code checking\u0026#39;) { steps { script { //引入sonarqubeScanner工具 scannerHome= tool \u0026#39;SonarQube\u0026#39; } withSonarQubeEnv(\u0026#39;SonarQube\u0026#39;) { //引入SonarQube的服务器环境 sh \u0026#34;${scannerHome}/bin/sonar-scanner\u0026#34; } } } ","tags":null,"title":"jenkins集成sonarQube","type":"docs"},{"authors":null,"categories":null,"content":"新建项目 复制cloud-comsumer-order8011\n重命名为 cloud-openfeign-comsumer-order8011\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; service 新建服务接口\n添加@Component注解\n添加@FeignClient(value = \u0026quot;CLOUD-PAYMENT-SERVICE\u0026quot;)注解\n并且接口方法需要与提供方的controller方法保持一致\npackage com.cloud.comsumer.order.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import cn.hutool.json.JSONObject; @Component @FeignClient(value = \u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;) public interface PaymentFeignService { @GetMapping(value = \u0026#34;/payment/get/{id}\u0026#34;) public JSONObject findById(@PathVariable(\u0026#34;id\u0026#34;)Long id); } controller package com.cloud.comsumer.order.contrller; import javax.annotation.Resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import com.cloud.comsumer.order.service.PaymentFeignService; import cn.hutool.json.JSONObject; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020/7/28 11:24 **/ @RestController @Slf4j public class OrderController { @Resource private PaymentFeignService paymentFeignService; /** * http://localhost:8011/consumer/payment/get/1 * @param id * @return */ @GetMapping(value = \u0026#34;/consumer/payment/get/{id}\u0026#34;) public JSONObject getPaymentById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return paymentFeignService.findById(id); } } 启动类 给启动昂类添加@EnableFeignClients注解\n测试 启动cloud-eureka-server7001\n启动cloud-eureka-server7002\n启动cloud.provider.payment8001\n启动cloud.provider.payment8002\n启动cloud-openfeign-comsumer-order8011\n访问http://localhost:8011/consumer/payment/get/1\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"74bbdc8ac1838245864f8a8543b5e49f","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/","section":"notes","summary":"新建项目 复制cloud-comsumer-order8011\n重命名为 cloud-openfeign-comsumer-order8011\npom \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; service 新建服务接口\n添加@Component注解\n添加@FeignClient(value = \u0026quot;CLOUD-PAYMENT-SERVICE\u0026quot;)注解\n并且接口方法需要与提供方的controller方法保持一致\npackage com.cloud.comsumer.order.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import cn.hutool.json.JSONObject; @Component @FeignClient(value = \u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;) public interface PaymentFeignService { @GetMapping(value = \u0026#34;/payment/get/{id}\u0026#34;) public JSONObject findById(@PathVariable(\u0026#34;id\u0026#34;)Long id); } controller package com.cloud.comsumer.order.contrller; import javax.annotation.Resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import com.cloud.comsumer.order.service.PaymentFeignService; import cn.hutool.json.JSONObject; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020/7/28 11:24 **/ @RestController @Slf4j public class OrderController { @Resource private PaymentFeignService paymentFeignService; /** * http://localhost:8011/consumer/payment/get/1 * @param id * @return */ @GetMapping(value = \u0026#34;/consumer/payment/get/{id}\u0026#34;) public JSONObject getPaymentById(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return paymentFeignService.","tags":null,"title":"openfeign服务调用","type":"docs"},{"authors":null,"categories":null,"content":"Ribbon负载均衡的八种算法，其中ResponseTimeWeightedRule已废除    规则名称 特点     AvailabilityFilteringRule 过滤掉一直连接失败的被标记为circuit tripped（电路跳闸）的后端Service，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤Server的逻辑，其实就是检查status的记录的各个Server的运行状态   BestAvailableRule 选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过   RandomRule 随机选择一个Server   ResponseTimeWeightedRule 已废弃，作用同WeightedResponseTimeRule   RetryRule 对选定的负责均衡策略机上充值机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的Server   RoundRobinRule 轮询选择，轮询index，选择index对应位置Server   WeightedResponseTimeRule 根据相应时间加权，相应时间越长，权重越小，被选中的可能性越低   ZoneAvoidanceRule （默认是这个）负责判断Server所Zone的性能Server的可用性选择Server，在没有Zone的环境下，类似于轮询（RoundRobinRule）    Ribbon负载规则替换 复制项目cloud-comsumer-order8011\n重命名为cloud-ribbon-comsumer-order8011\n新建com.cloud.comsumer.myrule包\n新建Myrule规则类\npackage com.cloud.comsumer.myrule; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; /** * 自定义负载均衡路由规则类 * * @author yzg * @date 2020/7/27 15:15 **/ @Configuration public class CloudRole { @Bean public IRule myRule() { // 定义为随机  return new RandomRule(); } } 启动类添加注解\n@RibbonClient(name = \u0026quot;CLOUD-PAYMENT-SERVICE\u0026quot;, configuration = Myrule.class)\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-provider-payment8001\n运行cloud-provider-payment8002\n运行cloud-ribbon-comsumer-order8011\n不断的访问http://localhost:8011/consumer/payment/get/1\n原理 负载均衡算法：第N次请求数 % 服务器集群总数量 = 实际调用服务器位置下标\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"6dc12021e0a04244acd99975347f7fc0","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/ribbon%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/ribbon%E8%B4%9F%E8%BD%BD%E8%A7%84%E5%88%99/","section":"notes","summary":"Ribbon负载均衡的八种算法，其中ResponseTimeWeightedRule已废除    规则名称 特点     AvailabilityFilteringRule 过滤掉一直连接失败的被标记为circuit tripped（电路跳闸）的后端Service，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤Server的逻辑，其实就是检查status的记录的各个Server的运行状态   BestAvailableRule 选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过   RandomRule 随机选择一个Server   ResponseTimeWeightedRule 已废弃，作用同WeightedResponseTimeRule   RetryRule 对选定的负责均衡策略机上充值机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的Server   RoundRobinRule 轮询选择，轮询index，选择index对应位置Server   WeightedResponseTimeRule 根据相应时间加权，相应时间越长，权重越小，被选中的可能性越低   ZoneAvoidanceRule （默认是这个）负责判断Server所Zone的性能Server的可用性选择Server，在没有Zone的环境下，类似于轮询（RoundRobinRule）    Ribbon负载规则替换 复制项目cloud-comsumer-order8011\n重命名为cloud-ribbon-comsumer-order8011\n新建com.cloud.comsumer.myrule包\n新建Myrule规则类\npackage com.cloud.comsumer.myrule; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; /** * 自定义负载均衡路由规则类 * * @author yzg * @date 2020/7/27 15:15 **/ @Configuration public class CloudRole { @Bean public IRule myRule() { // 定义为随机  return new RandomRule(); } } 启动类添加注解","tags":null,"title":"Ribbon负载规则","type":"docs"},{"authors":null,"categories":null,"content":"前提条件 安装MYSQL数据库 新建sonnar数据库\n下载安装 下载链接： https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-6.7.7.zip\n解压sonnar并配置权限\nyum install unzip\runzip sonarqube-6.7.7.zip\rmv /root/sonarqube-6.7.7./* /opt/sonar useradd sonar chown -R sonar. /opt/sonar\r配置 vim /opt/sonar/conf/sonar.properties # 配置数据库\rsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;rewriteBatchedStatements=true\u0026amp;useConfigs=maxPerformance\rsonar.jdbc.username=root\rsonar.jdbc.password=root\rsonar.sorceEncoding=UTF-8\rsonar.login=admin\rsonar.password=admin\r# 配置端口\rsonar.web.port=9000\r启动 不能用root账号启动\nsu sonar /opt/sonar/bin/linux-x86-64/sonar.sh start 查看日志\ntail -f /opt/sonar/logs/sonar.log 安装中文插件 下载地址\n下载好的jar包放到sonar安装目录下extensions/plugins重启即可\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"c191979e13d36f73364beb038e5f7a00","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/sonarqube%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/jenkins-study/sonarqube%E5%AE%89%E8%A3%85/","section":"notes","summary":"前提条件 安装MYSQL数据库 新建sonnar数据库\n下载安装 下载链接： https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-6.7.7.zip\n解压sonnar并配置权限\nyum install unzip\runzip sonarqube-6.7.7.zip\rmv /root/sonarqube-6.7.7./* /opt/sonar useradd sonar chown -R sonar. /opt/sonar\r配置 vim /opt/sonar/conf/sonar.properties # 配置数据库\rsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;rewriteBatchedStatements=true\u0026amp;useConfigs=maxPerformance\rsonar.jdbc.username=root\rsonar.jdbc.password=root\rsonar.sorceEncoding=UTF-8\rsonar.login=admin\rsonar.password=admin\r# 配置端口\rsonar.web.port=9000\r启动 不能用root账号启动\nsu sonar /opt/sonar/bin/linux-x86-64/sonar.sh start 查看日志\ntail -f /opt/sonar/logs/sonar.log 安装中文插件 下载地址\n下载好的jar包放到sonar安装目录下extensions/plugins重启即可","tags":null,"title":"sonarQube安装","type":"docs"},{"authors":null,"categories":null,"content":"安装运行 docker-registry 参考：https://www.funtl.com/zh/docs-docker/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-docker-registry\n#容器运行 你可以通过获取官方 registry 镜像来运行。\ndocker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。\ndocker run -d \\  -p 5000:5000 \\  -v /opt/data/registry:/var/lib/registry \\  registry 输入 http://你的IP:5000/v2/_catalog 表示私有仓库搭建成功并且内容为空。\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"8e3151311e3c6d5cb564397cfaca5902","permalink":"https://academia-hugo.netlify.com/notes/docker-study/docker%E7%A7%81%E6%9C%89%E5%BA%93%E5%AE%89%E8%A3%85/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/docker%E7%A7%81%E6%9C%89%E5%BA%93%E5%AE%89%E8%A3%85/","section":"notes","summary":"安装运行 docker-registry 参考：https://www.funtl.com/zh/docs-docker/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-docker-registry\n#容器运行 你可以通过获取官方 registry 镜像来运行。\ndocker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。\ndocker run -d \\  -p 5000:5000 \\  -v /opt/data/registry:/var/lib/registry \\  registry 输入 http://你的IP:5000/v2/_catalog 表示私有仓库搭建成功并且内容为空。","tags":null,"title":"安装docker-registry","type":"docs"},{"authors":null,"categories":null,"content":"下载 下载链接：https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.6.1.tgz\n将文件移动到/opt目录下\n解压会在当前目录生成harbor目录\ntar xvf harbor-offline-installer-v1.6.1.tgz 修改harbor.cfg vim harbor/harbor.cfg hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost，此处我设置为本地ip\nhostname = 172.16.50.37\rHarbor启动后，管理员UI登录的密码，默认是Harbor12345\nharbor_admin_password = Harbor12345\r认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证\nauth_mode = db_auth\r是否开启自注册\nself_registration = on\rToken有效时间，默认30分钟\ntoken_expiration = 30\r启动 Harbor 在harbor目录下执行\n./install.sh 查看compose状态\ndocker-compose ps 修改端口 在公网上，一般情况下都不暴露默认端口，避免被攻击！ 以下修改harbor的默认80端口为其他端口！\n修改docker-compose.yml 修改common/templates/registry/config.yml文件 重新启动并生成配置文件\ndocker-compose stop ./install.sh 访问 输入http://你的IP:18080/harbor/sign-in 输入用户名admin，默认密码（或已修改密码） 原文链接：https://blog.csdn.net/funtaster/java/article/details/83268974\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"cd156e1968fe3721d1e6eed8c2f37d64","permalink":"https://academia-hugo.netlify.com/notes/docker-study/%E6%90%AD%E5%BB%BAharbor/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/%E6%90%AD%E5%BB%BAharbor/","section":"notes","summary":"下载 下载链接：https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.6.1.tgz\n将文件移动到/opt目录下\n解压会在当前目录生成harbor目录\ntar xvf harbor-offline-installer-v1.6.1.tgz 修改harbor.cfg vim harbor/harbor.cfg hostname设置访问地址，可以使用ip、域名，不可以设置为127.0.0.1或localhost，此处我设置为本地ip\nhostname = 172.16.50.37\rHarbor启动后，管理员UI登录的密码，默认是Harbor12345\nharbor_admin_password = Harbor12345\r认证方式，这里支持多种认证方式，如LADP、本次存储、数据库认证。默认是db_auth，mysql数据库认证\nauth_mode = db_auth\r是否开启自注册\nself_registration = on\rToken有效时间，默认30分钟\ntoken_expiration = 30\r启动 Harbor 在harbor目录下执行\n./install.sh 查看compose状态\ndocker-compose ps 修改端口 在公网上，一般情况下都不暴露默认端口，避免被攻击！ 以下修改harbor的默认80端口为其他端口！\n修改docker-compose.yml 修改common/templates/registry/config.yml文件 重新启动并生成配置文件\ndocker-compose stop ./install.sh 访问 输入http://你的IP:18080/harbor/sign-in 输入用户名admin，默认密码（或已修改密码） 原文链接：https://blog.csdn.net/funtaster/java/article/details/83268974","tags":null,"title":"搭建Harbor","type":"docs"},{"authors":null,"categories":null,"content":"giteehttps://gitee.com/MrPen/springcloud2020_microservices/tree/master/com-yzg-springcloud\n建module 新建cloud.provider.payment8001项目\n改POM pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;cloud.provider.payment8001\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;支付模块\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 解决 Failure to transfer * from http://repo1.maven.org/maven2 Failure to transfer org.apache.maven:maven-archiver:pom:2.4.1 from http://repo1.maven.org/maven2 was cached in the local repository\n原因 maven下载jar中断没成功。\n解决办法 1.将当前用户目录下的.m2目录下所有以 .lastupdate 结尾的文件全部删除掉\n2.maven\u0026ndash;\u0026raquo; update project\n写YML application.yml\nserver:\rport: 8001\rspring:\rapplication:\rname: cloud-payment-service\rdatasource:\r# 当前数据源操作类型\rtype: com.alibaba.druid.pool.DruidDataSource\r# mysql驱动类\rdriver-class-name: com.mysql.cj.jdbc.Driver\rurl: jdbc:mysql://localhost:3306/cloud2020?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT%2B8\rusername: root\rpassword: admin\rmybatis:\rtype-aliases-package: com.cloud.provider.payment.entities\r#showSql\rlogging:\rlevel:\rcom:\rexample:\rmapper : debug\r启动类 package com.cloud.provider.payment; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026#34;com.cloud.provider.payment.dao\u0026#34;) public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class, args); } } 写业务 entities\npackage com.cloud.provider.payment.entities; public class Payment { private Long id; private String serial; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getSerial() { return serial; } public void setSerial(String serial) { this.serial = serial; } @Override public String toString() { return \u0026#34;Payment [id=\u0026#34; + id + \u0026#34;, serial=\u0026#34; + serial + \u0026#34;]\u0026#34;; } } dao\npackage com.cloud.provider.payment.dao; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import com.cloud.provider.payment.entities.Payment; @Mapper public interface PaymentMapper { /** * 新增 * * @param payment * @return */ @Insert(\u0026#34;insert into payment(id,serial) value(#{id},#{serial})\u0026#34;) int save(Payment payment); /** * 查询 * * @param id * @return */ @Select(\u0026#34;select * from payment where id = #{id} \u0026#34;) Payment findById(@Param(\u0026#34;id\u0026#34;) Long id); } service\npackage com.cloud.provider.payment.service; import org.apache.ibatis.annotations.Param; import com.cloud.provider.payment.entities.Payment; public interface PaymentService { /** * 新增 * * @param payment * @return */ public int save(Payment payment); /** * 查询 * * @param id * @return */ public Payment findById(@Param(\u0026#34;id\u0026#34;) Long id); } serviceimpl\npackage com.cloud.provider.payment.service.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.cloud.provider.payment.entities.Payment; import com.cloud.provider.payment.dao.PaymentMapper; import com.cloud.provider.payment.service.PaymentService; @Service public class PaymentServiceImpl implements PaymentService{ @Autowired private PaymentMapper paymentDao; @Override public int save(Payment payment) { // TODO Auto-generated method stub \treturn paymentDao.save(payment); } @Override public Payment findById(Long id) { // TODO Auto-generated method stub \treturn paymentDao.findById(id); } } controller\npackage com.cloud.provider.payment.contrller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.ResponseBody; import com.cloud.provider.payment.entities.CommomResult; import com.cloud.provider.payment.entities.Payment; import com.cloud.provider.payment.service.PaymentService; import cn.hutool.json.JSONObject; import cn.hutool.json.JSONUtil; import lombok.extern.slf4j.Slf4j; @Controller @Slf4j public class PaymentController { @Autowired private PaymentService paymentService; private static final Logger log = LoggerFactory.getLogger(PaymentController.class); @ResponseBody @PostMapping(value = \u0026#34;/payment/save\u0026#34;) public JSONObject save(Payment payment) { CommomResult commomResult=new CommomResult(); try { int result = paymentService.save(payment); if (result \u0026gt; 0) { commomResult.setCode(200); commomResult.setData(result); commomResult.setMassage(\u0026#34;插入数据库成功\u0026#34;); } else { commomResult.setCode(400); commomResult.setMassage(\u0026#34;插入数据库失败\u0026#34;); } }catch (Exception e) { commomResult.setCode(400); commomResult.setMassage(\u0026#34;插入数据库失败\u0026#34;); } return JSONUtil.parseObj(commomResult, true); } @ResponseBody @GetMapping(value = \u0026#34;/payment/get/{id}\u0026#34;) public JSONObject findById(@PathVariable(\u0026#34;id\u0026#34;)Long id) { Payment result = paymentService.findById(id); CommomResult commomResult=new CommomResult(); if (result != null) { commomResult.setCode(200); commomResult.setData(result); commomResult.setMassage(\u0026#34;查询成功\u0026#34;); } else { commomResult.setCode(400); commomResult.setMassage(\u0026#34;查询为空\u0026#34;); } return JSONUtil.parseObj(commomResult, true); } } 测试 http://localhost:8001/payment/get/1\nhttp://localhost:8001/payment/get/3\nhttp://localhost:8001//payment/save?id=3\u0026amp;serial=测试数据\nhttp://localhost:8001//payment/save?id=3\u0026amp;serial=测试数据\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"26f82cd076665ba3b338088084fd6265","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/","section":"notes","summary":"giteehttps://gitee.com/MrPen/springcloud2020_microservices/tree/master/com-yzg-springcloud\n建module 新建cloud.provider.payment8001项目\n改POM pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;cloud.provider.payment8001\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;支付模块\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql-connector-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"支付模块构建","type":"docs"},{"authors":null,"categories":null,"content":"POM \u0026lt;!--eureka client--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml eureka:\rclient:\rregister-with-eureka: true\rfetch-registry: true\rservice-url:\rdefaultZone: http://localhost:7001/eureka\r集群版\n # 集群版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\r启动类 @SpringBootApplication @EnableEurekaClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class, args); } } 效果 先运行注册中心，再运行提供者\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"2026701d1a01f9c93e7717d3579b7212","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E5%85%A5%E9%A9%BBeureka-server/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E5%85%A5%E9%A9%BBeureka-server/","section":"notes","summary":"POM \u0026lt;!--eureka client--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; yml eureka:\rclient:\rregister-with-eureka: true\rfetch-registry: true\rservice-url:\rdefaultZone: http://localhost:7001/eureka\r集群版\n # 集群版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\r启动类 @SpringBootApplication @EnableEurekaClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class, args); } } 效果 先运行注册中心，再运行提供者","tags":null,"title":"服务入驻eureka-server","type":"docs"},{"authors":null,"categories":null,"content":"示例 import org.springframework.cloud.client.discovery.DiscoveryClient; @Resource private DiscoveryClient discoveryClient; @GetMapping(value = \u0026#34;/payment/discovery\u0026#34;) public Object discovery(){ List\u0026lt;String\u0026gt; services = discoveryClient.getServices(); for (String element : services) { log.info(\u0026#34;****element: \u0026#34; +element); } List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;); for (ServiceInstance instance:instances) { log.info(instance.getServiceId()+\u0026#34;\\t\u0026#34;+instance.getHost()+\u0026#34;\\t\u0026#34;+instance.getPort()+\u0026#34;\\t\u0026#34;+instance.getUri()); } return this.discoveryClient; } 启动类添加@EnableDiscoveryClient注解 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001 控制台输出\n2020-07-21 23:03:11.050 INFO 13360 --- [nio-8001-exec-1] c.c.p.p.contrller.PaymentController : ****element: cloud-payment-service\r2020-07-21 23:03:11.050 INFO 13360 --- [nio-8001-exec-1] c.c.p.p.contrller.PaymentController : CLOUD-PAYMENT-SERVICE\tPC-20190228DBGH\t8001\thttp://PC-20190228DBGH:8001\r","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"ac8d2888184130eb537b780663c1ddc6","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0discovery/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0discovery/","section":"notes","summary":"示例 import org.springframework.cloud.client.discovery.DiscoveryClient; @Resource private DiscoveryClient discoveryClient; @GetMapping(value = \u0026#34;/payment/discovery\u0026#34;) public Object discovery(){ List\u0026lt;String\u0026gt; services = discoveryClient.getServices(); for (String element : services) { log.info(\u0026#34;****element: \u0026#34; +element); } List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026#34;CLOUD-PAYMENT-SERVICE\u0026#34;); for (ServiceInstance instance:instances) { log.info(instance.getServiceId()+\u0026#34;\\t\u0026#34;+instance.getHost()+\u0026#34;\\t\u0026#34;+instance.getPort()+\u0026#34;\\t\u0026#34;+instance.getUri()); } return this.discoveryClient; } 启动类添加@EnableDiscoveryClient注解 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud.provider.payment8001 控制台输出\n2020-07-21 23:03:11.050 INFO 13360 --- [nio-8001-exec-1] c.c.p.p.contrller.PaymentController : ****element: cloud-payment-service\r2020-07-21 23:03:11.050 INFO 13360 --- [nio-8001-exec-1] c.c.p.p.contrller.PaymentController : CLOUD-PAYMENT-SERVICE\tPC-20190228DBGH\t8001\thttp://PC-20190228DBGH:8001\r","tags":null,"title":"服务发现Discovery","type":"docs"},{"authors":null,"categories":null,"content":"提供端 新建项目cloud-consul-provider-payment8006\nPOM 添加以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;artifactId\u0026gt;cloud-consul-provider-payment8006\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;Zookeeper服务提供者\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--SpringCloud consul-server--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; controller package com.cloud.provider.payment.contrller; import java.util.UUID; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020-07-27 12:00 **/ @RestController @Slf4j public class PaymentController { @Value(\u0026#34;${server.port}\u0026#34;) private String serverPort; /** * http://localhost:8006/payment/consul * * @return */ @RequestMapping(value = \u0026#34;payment/consul\u0026#34;) public String paymentZk() { return \u0026#34;SpringCloud with consul:\u0026#34; + serverPort + \u0026#34;\\t\u0026#34; + UUID.randomUUID().toString(); } } yml server:\r# consul服务端口\rport: 8006\rspring:\rapplication:\rname: cloud-provider-payment\rcloud:\rconsul:\r# consul注册中心地址\rhost: 203.176.95.155\rport: 8500\rdiscovery:\rhostname: 203.176.95.155\rservice-name: ${spring.application.name}\r启动类 package com.cloud.provider.payment.contrller; import java.util.UUID; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020-07-27 12:00 **/ @RestController @Slf4j public class PaymentController { @Value(\u0026#34;${server.port}\u0026#34;) private String serverPort; /** * http://localhost:8006/payment/consul * * @return */ @RequestMapping(value = \u0026#34;payment/consul\u0026#34;) public String paymentZk() { return \u0026#34;SpringCloud with consul:\u0026#34; + serverPort + \u0026#34;\\t\u0026#34; + UUID.randomUUID().toString(); } } 消费端 新建项目cloud-consul-consumer-order8012\nPOM \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;artifactId\u0026gt;cloud-consul-consumer-order8012\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;consul服务消费者\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--SpringCloud consul-server--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; controller package com.cloud.consumer.order.comtroller; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; /** * * @author yzg * @create 2020/07/26 */ @RestController @Slf4j public class OrderConsulController { public static final String INVOKE_URL = \u0026#34;http://cloud-provider-payment\u0026#34;; @Resource private RestTemplate restTemplate; /** * http://localhost:8012/consumer/payment/consul * @return */ @GetMapping(\u0026#34;/consumer/payment/consul\u0026#34;) public String payment(){ return restTemplate.getForObject(INVOKE_URL + \u0026#34;/payment/consul\u0026#34;,String.class ); } } Config package com.cloud.consumer.order.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; /** * @author yzg * @create 2020/07/27 */ @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } } yml server:\rport: 8012\rspring:\rapplication:\rname: cloud-consumer-order\rcloud:\rconsul:\rhost: 203.176.95.155\rport: 8500\rdiscovery:\rservice-name: ${spring.application.name}\r启动类 package com.cloud.consumer.order; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class OrderConsulMain8012 { public static void main(String[] args) { SpringApplication.run(OrderConsulMain8012.class, args); } } 测试 启动这两个项目\n访问：http://localhost:8012/consumer/payment/consul\n注意事项 服务必需是健康的才能访问得到\n所以需要在pom添加健康监控的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置文件修改\nserver:\rport: 8006\rspring:\rapplication:\rname: cloud-provider-pay\rcloud:\rconsul:\rhost: 203.176.95.155\rport: 8500\rdiscovery:\rservice-name: ${spring.application.name}\rheartbeat:\renabled: true\r","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"abc69be0a111d6f3b5ddb77c4f0ab490","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8Cconsul/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8Cconsul/","section":"notes","summary":"提供端 新建项目cloud-consul-provider-payment8006\nPOM 添加以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;com-yzg-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;artifactId\u0026gt;cloud-consul-provider-payment8006\u0026lt;/artifactId\u0026gt; \u0026lt;description\u0026gt;Zookeeper服务提供者\u0026lt;/description\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--SpringCloud consul-server--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yzg.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cloud-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; controller package com.cloud.provider.payment.contrller; import java.util.UUID; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import lombok.extern.slf4j.Slf4j; /** * @author yzg * @create 2020-07-27 12:00 **/ @RestController @Slf4j public class PaymentController { @Value(\u0026#34;${server.","tags":null,"title":"服务注册consul","type":"docs"},{"authors":null,"categories":null,"content":"提供者 复制cloud-provider-payment8001\n修改项目名和pom文件内的artifactId为cloud-provider-payment8002\n消费者\ncontroller\n访问提供者的地址修改为在eureka上注册的名称CLOUD-PAYMENT-SERVICE\npackage com.cloud.comsumer.order.contrller; import javax.annotation.Resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import cloud.api.common.entities.CommomResult; import cloud.api.common.entities.Payment; /** * @author yangzhangguan * @create 2020-07-20 17:23 **/ @RestController public class OrderController { /** * 通过在eureka上注册过的微服务名称调用 */ public static final String PAYMENT_URL = \u0026#34;http://CLOUD-PAYMENT-SERVICE\u0026#34;; @Resource private RestTemplate restTemplate; /** * * @param payment * @return */ @GetMapping(\u0026#34;/consumer/payment/save\u0026#34;) public CommomResult\u0026lt;Payment\u0026gt; save(@RequestBody Payment payment) { return restTemplate.postForObject(PAYMENT_URL + \u0026#34;/payment/save\u0026#34;, payment, CommomResult.class); } @GetMapping(\u0026#34;/consumer/payment/get/{id}\u0026#34;) public CommomResult\u0026lt;Payment\u0026gt; getPayment(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return restTemplate.getForObject(PAYMENT_URL + \u0026#34;/payment/get/\u0026#34; + id, CommomResult.class); } } 配置类\n添加@LoadBalanced注解\npackage com.cloud.comsumer.order.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; /** * @author yangzhangguan * @date 2020-07-20 17:27 **/ @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate() { return new RestTemplate(); } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-provider-payment8001\n运行cloud-provider-payment8002\n运行cloud-comsumer-order8011\n不停访问：http://localhost:8011//consumer/payment/get/1\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"46076557d50dcb37714c9e8e3bc5a9ea","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8/","section":"notes","summary":"提供者 复制cloud-provider-payment8001\n修改项目名和pom文件内的artifactId为cloud-provider-payment8002\n消费者\ncontroller\n访问提供者的地址修改为在eureka上注册的名称CLOUD-PAYMENT-SERVICE\npackage com.cloud.comsumer.order.contrller; import javax.annotation.Resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import cloud.api.common.entities.CommomResult; import cloud.api.common.entities.Payment; /** * @author yangzhangguan * @create 2020-07-20 17:23 **/ @RestController public class OrderController { /** * 通过在eureka上注册过的微服务名称调用 */ public static final String PAYMENT_URL = \u0026#34;http://CLOUD-PAYMENT-SERVICE\u0026#34;; @Resource private RestTemplate restTemplate; /** * * @param payment * @return */ @GetMapping(\u0026#34;/consumer/payment/save\u0026#34;) public CommomResult\u0026lt;Payment\u0026gt; save(@RequestBody Payment payment) { return restTemplate.postForObject(PAYMENT_URL + \u0026#34;/payment/save\u0026#34;, payment, CommomResult.","tags":null,"title":"服务的高可用","type":"docs"},{"authors":null,"categories":null,"content":"创建镜像仓库 地址：https://cr.console.aliyun.com/\n推送镜像 点击管理 sudo docker login --username=[阿里云账号] registry.cn-hangzhou.aliyuncs.com sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/mrpen/study:[镜像版本号] sudo docker push registry.cn-hangzhou.aliyuncs.com/mrpen/study:[镜像版本号] ","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"e0d13e1932c30eed42b21f0cb145725f","permalink":"https://academia-hugo.netlify.com/notes/docker-study/%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E9%98%BF%E9%87%8C%E4%BA%91/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/docker-study/%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E9%98%BF%E9%87%8C%E4%BA%91/","section":"notes","summary":"创建镜像仓库 地址：https://cr.console.aliyun.com/\n推送镜像 点击管理 sudo docker login --username=[阿里云账号] registry.cn-hangzhou.aliyuncs.com sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/mrpen/study:[镜像版本号] sudo docker push registry.cn-hangzhou.aliyuncs.com/mrpen/study:[镜像版本号] ","tags":null,"title":"本地镜像上传阿里云","type":"docs"},{"authors":null,"categories":null,"content":"新建项目 设置编码 注解生效 配置jdk 文件过滤 pom.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com-yzg-springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;com.yzg.springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.17\u0026lt;/log4j.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.16.18\u0026lt;/lombok.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.0.18\u0026lt;/mysql.version\u0026gt; \u0026lt;druid.verison\u0026gt;1.1.16\u0026lt;/druid.verison\u0026gt; \u0026lt;mybatis.spring.boot.verison\u0026gt;1.3.0\u0026lt;/mybatis.spring.boot.verison\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--spring boot 2.2.2--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud Hoxton.SR1--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Hoxton.SR1\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud alibaba 2.1.0.RELEASE--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Druid --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${druid.verison}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-springboot整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis.spring.boot.verison}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${junit.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${log4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;addResources\u0026gt;true\u0026lt;/addResources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; DependencyManagement和Dependencies的区别 dependencyManagement Maven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。 通常会在一个组织或者项目的最顶层的父pom中看到dependencyManagement元素\n使用pom.xml中的dependencyManagement元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。 Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"713466a18074389522770c8113b80946","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/%E7%88%B6%E5%B7%A5%E7%A8%8B/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/cloud-study/%E7%88%B6%E5%B7%A5%E7%A8%8B/","section":"notes","summary":"新建项目 设置编码 注解生效 配置jdk 文件过滤 pom.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com-yzg-springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;com.yzg.springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.17\u0026lt;/log4j.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.16.18\u0026lt;/lombok.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.0.18\u0026lt;/mysql.version\u0026gt; \u0026lt;druid.verison\u0026gt;1.1.16\u0026lt;/druid.verison\u0026gt; \u0026lt;mybatis.spring.boot.verison\u0026gt;1.3.0\u0026lt;/mybatis.spring.boot.verison\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--spring boot 2.2.2--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud Hoxton.SR1--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Hoxton.SR1\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring cloud alibaba 2.1.0.RELEASE--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!","tags":null,"title":"父工程","type":"docs"},{"authors":null,"categories":null,"content":"配置tomcat远程访问权限 修改tomcat安装目录下的tomcat-users.xml\nvim /opt/apache-tomcat-8.5.57/conf/tomcat-users.xml  \u0026lt;role rolename=\u0026quot;admin-gui\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;admin-script\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-gui\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-script\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-jmx\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-status\u0026quot;/\u0026gt;\r\u0026lt;user username=\u0026quot;admin\u0026quot; password=\u0026quot;admin\u0026quot; roles=\u0026quot;manager-gui,manager-script,manager-jmx,manager-status,admin-script,admin-gui\u0026quot;/\u0026gt;\r\u0026lt;/tomcat-users\u0026gt;\r重启\n./shutdown.sh\r./startup.sh\r修改webapps/manager/META-INF/context.xml配置文件\nvim /opt/apache-tomcat-8.5.57/webapps/manager/META-INF/context.xml 给value标签加上注释\n\u0026lt;!-- \u0026lt;Valve className=\u0026quot;org.apache.catalina.valves.RemoteAddrValve\u0026quot;\rallow=\u0026quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\u0026quot; /\u0026gt;--\u0026gt;\r点击 manager webapp 安装Deploy to container插件 创建自由风格项目 配置Git地址 构建\u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; 执行shell \u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; 输入mvn clean package 构建后操作\u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; Deploy war to container 立即构建\n","date":1593298800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593298800,"objectID":"de77dedda8ea2958c089026857e5acc1","permalink":"https://academia-hugo.netlify.com/notes/jenkins-study/%E8%87%AA%E7%94%B1%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90tomcat%E9%A1%B9%E7%9B%AE/","publishdate":"2020-06-28T00:00:00+01:00","relpermalink":"/notes/jenkins-study/%E8%87%AA%E7%94%B1%E9%A3%8E%E6%A0%BC%E9%9B%86%E6%88%90tomcat%E9%A1%B9%E7%9B%AE/","section":"notes","summary":"配置tomcat远程访问权限 修改tomcat安装目录下的tomcat-users.xml\nvim /opt/apache-tomcat-8.5.57/conf/tomcat-users.xml  \u0026lt;role rolename=\u0026quot;admin-gui\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;admin-script\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-gui\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-script\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-jmx\u0026quot;/\u0026gt;\r\u0026lt;role rolename=\u0026quot;manager-status\u0026quot;/\u0026gt;\r\u0026lt;user username=\u0026quot;admin\u0026quot; password=\u0026quot;admin\u0026quot; roles=\u0026quot;manager-gui,manager-script,manager-jmx,manager-status,admin-script,admin-gui\u0026quot;/\u0026gt;\r\u0026lt;/tomcat-users\u0026gt;\r重启\n./shutdown.sh\r./startup.sh\r修改webapps/manager/META-INF/context.xml配置文件\nvim /opt/apache-tomcat-8.5.57/webapps/manager/META-INF/context.xml 给value标签加上注释\n\u0026lt;!-- \u0026lt;Valve className=\u0026quot;org.apache.catalina.valves.RemoteAddrValve\u0026quot;\rallow=\u0026quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\u0026quot; /\u0026gt;--\u0026gt;\r点击 manager webapp 安装Deploy to container插件 创建自由风格项目 配置Git地址 构建\u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; 执行shell \u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; 输入mvn clean package 构建后操作\u0026mdash;\u0026ndash;\u0026raquo;\u0026gt; Deploy war to container 立即构建","tags":null,"title":"自由风格集成tomcat项目","type":"docs"},{"authors":null,"categories":null,"content":"Docker Dockerfile 摘自：https://www.runoob.com/docker/docker-dockerfile.html\n什么是 Dockerfile？ Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n使用 Dockerfile 定制镜像 这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可。\n1、下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）\n在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：\nFROM nginx\rRUN echo '这是一个本地构建的nginx镜像' \u0026gt; /usr/share/nginx/html/index.html\r2、FROM 和 RUN 指令的作用\nFROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\nRUN：用于执行后面跟着的命令行命令。有以下俩种格式：\nshell 格式：\nRUN \u0026lt;命令行命令\u0026gt;\r# \u0026lt;命令行命令\u0026gt; 等同于，在终端操作的 shell 命令。\rexec 格式：\nRUN [\u0026quot;可执行文件\u0026quot;, \u0026quot;参数1\u0026quot;, \u0026quot;参数2\u0026quot;]\r# 例如：\r# RUN [\u0026quot;./test.php\u0026quot;, \u0026quot;dev\u0026quot;, \u0026quot;offline\u0026quot;] 等价于 RUN ./test.php dev offline\r注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：\nFROM centos RUN yum install wget RUN wget -O redis.tar.gz \u0026ldquo;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026quot; RUN tar -xvf redis.tar.gz 以上执行会创建 3 层镜像。可简化为以下格式： FROM centos RUN yum install wget\n\u0026amp;\u0026amp; wget -O redis.tar.gz \u0026ldquo;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026quot;\n\u0026amp;\u0026amp; tar -xvf redis.tar.gz\n如上，以 \u0026amp;\u0026amp; 符号连接命令，这样执行后，只会创建 1 层镜像。\n开始构建镜像 在 Dockerfile 文件的存放目录下，执行构建动作。\n以下示例，通过目录下的 Dockerfile 构建一个 nginx:test（镜像名称:镜像标签）。\n注：最后的 . 代表本次执行的上下文路径，下一节会介绍。\n$ docker build -t nginx:test .\n以上显示，说明已经构建成功。\n上下文路径 上一节中，有提到指令最后一个 . 是上下文路径，那么什么是上下文路径呢？\n$ docker build -t nginx:test .\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n 指令详解 COPY 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。\n格式：\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;源路径1\u0026gt;... \u0026lt;目标路径\u0026gt;\rCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026quot;\u0026lt;源路径1\u0026gt;\u0026quot;,... \u0026quot;\u0026lt;目标路径\u0026gt;\u0026quot;]\r[\u0026ndash;chown=:]：可选参数，用户改变复制到容器内文件的拥有者和属组。\n\u0026lt;源路径\u0026gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：\nCOPY hom* /mydir/\rCOPY hom?.txt /mydir/\r\u0026lt;目标路径\u0026gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\nADD ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：\n ADD 的优点：在执行 \u0026lt;源文件\u0026gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 \u0026lt;目标路径\u0026gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。  CMD 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\n CMD 在docker run 时运行。 RUN 是在 docker build。  作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\n格式：\nCMD \u0026lt;shell 命令\u0026gt; CMD [\u0026quot;\u0026lt;可执行文件或命令\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param1\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param2\u0026gt;\u0026quot;,...] CMD [\u0026quot;\u0026lt;param1\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param2\u0026gt;\u0026quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数\r推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\nENTRYPOINT 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\n但是, 如果运行 docker run 时使用了 \u0026ndash;entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。\n优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\n格式：\nENTRYPOINT [\u0026quot;\u0026lt;executeable\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param1\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param2\u0026gt;\u0026quot;,...]\r可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n示例：\n假设已通过 Dockerfile 构建了 nginx:test 镜像：\nFROM nginx\rENTRYPOINT [\u0026quot;nginx\u0026quot;, \u0026quot;-c\u0026quot;] # 定参\rCMD [\u0026quot;/etc/nginx/nginx.conf\u0026quot;] # 变参 1、不传参运行\n$ docker run nginx:test\r容器内会默认运行以下命令，启动主进程。\nnginx -c /etc/nginx/nginx.conf\r2、传参运行\n$ docker run nginx:test -c /etc/nginx/new.conf\r容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)\nnginx -c /etc/nginx/new.conf\rENV 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\n格式：\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\rENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;...\r以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：\nENV NODE_VERSION 7.2.0\rRUN curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\u0026quot; \\\r\u0026amp;\u0026amp; curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\u0026quot;\rARG 构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n构建命令 docker build 中可以用 \u0026ndash;build-arg \u0026lt;参数名\u0026gt;=\u0026lt;值\u0026gt; 来覆盖。\n格式：\nARG \u0026lt;参数名\u0026gt;[=\u0026lt;默认值\u0026gt;]\rVOLUME 定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n作用：\n 避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。  格式：\nVOLUME [\u0026quot;\u0026lt;路径1\u0026gt;\u0026quot;, \u0026quot;\u0026lt;路径2\u0026gt;\u0026quot;...]\rVOLUME \u0026lt;路径\u0026gt;\r在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\nEXPOSE 仅仅只是声明端口。\n作用：\n 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。  格式：\nEXPOSE \u0026lt;端口1\u0026gt; [\u0026lt;端口2\u0026gt;...]\rWORKDIR 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\ndocker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。\n格式：\nWORKDIR \u0026lt;工作目录路径\u0026gt;\rUSER 用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\n格式：\nUSER \u0026lt;用户名\u0026gt;[:\u0026lt;用户组\u0026gt;]\rHEALTHCHECK 用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\n格式：\nHEALTHCHECK [选项] CMD \u0026lt;命令\u0026gt;：设置检查容器健康状况的命令\rHEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\rHEALTHCHECK [选项] CMD \u0026lt;命令\u0026gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。\rONBUILD 用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\n格式：\nONBUILD \u0026lt;其它指令\u0026gt;\rdocker执行dockerFile的流程 1.docker从基础镜像运行一个容器 2.执行一条指令并对容器作出修改 3.执行类似docker commit的操作提交一个新的镜像层 4.docker再给予刚提交的镜像运行一个新容器 5.执行dockerfile中的下一条指令直到所有指令都执行完成\n对应应用软件的三个阶段 dockerfile是软件的原材料 docker镜像是软件的交付品 docker容器是软件的运行态\n三者转化 dockerfile \u0026ndash;\u0026raquo; build- -\u0026raquo; docker镜像 - -\u0026raquo; run- -\u0026raquo; docker容器\n","date":1592953200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592953200,"objectID":"bea1a61a0c75d6e894e987619bc0e211","permalink":"https://academia-hugo.netlify.com/notes/docker-study/dockerfile/","publishdate":"2020-06-24T00:00:00+01:00","relpermalink":"/notes/docker-study/dockerfile/","section":"notes","summary":"Docker Dockerfile 摘自：https://www.runoob.com/docker/docker-dockerfile.html\n什么是 Dockerfile？ Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n使用 Dockerfile 定制镜像 这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可。\n1、下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）\n在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：\nFROM nginx\rRUN echo '这是一个本地构建的nginx镜像' \u0026gt; /usr/share/nginx/html/index.html\r2、FROM 和 RUN 指令的作用\nFROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\nRUN：用于执行后面跟着的命令行命令。有以下俩种格式：\nshell 格式：\nRUN \u0026lt;命令行命令\u0026gt;\r# \u0026lt;命令行命令\u0026gt; 等同于，在终端操作的 shell 命令。\rexec 格式：\nRUN [\u0026quot;可执行文件\u0026quot;, \u0026quot;参数1\u0026quot;, \u0026quot;参数2\u0026quot;]\r# 例如：\r# RUN [\u0026quot;./test.php\u0026quot;, \u0026quot;dev\u0026quot;, \u0026quot;offline\u0026quot;] 等价于 RUN ./test.php dev offline\r注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：","tags":null,"title":"dockerfile","type":"docs"},{"authors":null,"categories":null,"content":"在centos内构建centos容器，并在容器内安装jdk和tomcat 将apache-tomcat-9.0.36.tar.gz和jdk-8u112-linux-x64.tar.gz复制到/mydocker\n编写dockerFile vim dockerFile\nFROM centos MAINTAINER YZG@qq.com #把宿主机当前上下文的c.txt拷贝到容器/user/local/路径下 COPY c.txt /user/local/cincontainer.txt #把Java与tomcat添加到容器中 ADD jdk-8u112-linux-x64.tar.gz /user/local/ ADD apache-tomcat-9.0.36.tar.gz /user/local/ #安装VIM编辑器 RUN yum -y install vim #设置工作访问时候的WORKDIR路径，登录的落脚点 ENV MYPATH /user/local/ WORKDIR $MYPATH #配置java与tomcat环境变量 ENV JAVA_HOME /user/local/jdk1.8.0_112 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /user/local/apache-tomcat-9.0.36 ENV CATALINA_BASE /user/local/apache-tomcat-9.0.36 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #容器运行时监听的端口 EXPOSE 8080 #启动时运行Tomcat #ENTRYPOINT [\u0026#34;/user/local/apache-tomcat-9.0.36/bin/startup.sh\u0026#34;] #CMD[\u0026#34;/user/local/apache-tomcat-9.0.36/bin/catalina.sh\u0026#34;,\u0026#34;run\u0026#34;] CMD /user/local/apache-tomcat-9.0.36/bin/startup.sh \u0026amp;\u0026amp; tail -F /user/local/apache-tomcat-9.0.36/bin/logs/catalina.out 构建容器 docker build -f dockerFile . -t mycentos 运行容器 docker run -d -p 18080:8080 --name mycentos -v /mytomcat/test:/user/local/apache-tomcat-9.0.36/webapps/test -v /mytomcat/logs:/user/local/apache-tomcat-9.0.36/logs --privileged=true mycentos 运行成功！！！\n部署简单的web项目 2.1.在宿主机的/mytomcat/test文件下新建WEB-INF文件夹 2.在WEB-INF文件夹下新建web.xml 3.在/mytomcat/test下新建index.jsp\n4.编写web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE web-app PUBLIC \u0026#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026#34; \u0026#34;http://java.sun.com/dtd/web-app_2_3.dtd\u0026#34;\u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;display-name\u0026gt;myapp\u0026lt;/display-name\u0026gt; \u0026lt;description\u0026gt;This a description of my web app made by Eclipse\u0026lt;/description\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt; 5.编写index.jsp\n\u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; dockerFile successful!!!!!! \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 6.重启容器\ndocker restart 8ab8846816c0 7.运行成功 在宿主机上查看docker容器下tomcat日志 cat /mytomcat/logs/catalina.out ","date":1592953200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592953200,"objectID":"922008c822ca6977d2b4c0913dceb777","permalink":"https://academia-hugo.netlify.com/notes/docker-study/%E6%A1%88%E4%BE%8B%E4%B8%80/","publishdate":"2020-06-24T00:00:00+01:00","relpermalink":"/notes/docker-study/%E6%A1%88%E4%BE%8B%E4%B8%80/","section":"notes","summary":"在centos内构建centos容器，并在容器内安装jdk和tomcat 将apache-tomcat-9.0.36.tar.gz和jdk-8u112-linux-x64.tar.gz复制到/mydocker\n编写dockerFile vim dockerFile\nFROM centos MAINTAINER YZG@qq.com #把宿主机当前上下文的c.txt拷贝到容器/user/local/路径下 COPY c.txt /user/local/cincontainer.txt #把Java与tomcat添加到容器中 ADD jdk-8u112-linux-x64.tar.gz /user/local/ ADD apache-tomcat-9.0.36.tar.gz /user/local/ #安装VIM编辑器 RUN yum -y install vim #设置工作访问时候的WORKDIR路径，登录的落脚点 ENV MYPATH /user/local/ WORKDIR $MYPATH #配置java与tomcat环境变量 ENV JAVA_HOME /user/local/jdk1.8.0_112 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /user/local/apache-tomcat-9.0.36 ENV CATALINA_BASE /user/local/apache-tomcat-9.0.36 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #容器运行时监听的端口 EXPOSE 8080 #启动时运行Tomcat #ENTRYPOINT [\u0026#34;/user/local/apache-tomcat-9.0.36/bin/startup.sh\u0026#34;] #CMD[\u0026#34;/user/local/apache-tomcat-9.0.36/bin/catalina.sh\u0026#34;,\u0026#34;run\u0026#34;] CMD /user/local/apache-tomcat-9.0.36/bin/startup.sh \u0026amp;\u0026amp; tail -F /user/local/apache-tomcat-9.0.36/bin/logs/catalina.out 构建容器 docker build -f dockerFile . -t mycentos 运行容器 docker run -d -p 18080:8080 --name mycentos -v /mytomcat/test:/user/local/apache-tomcat-9.","tags":null,"title":"dockerfile案例","type":"docs"},{"authors":null,"categories":null,"content":"拉取镜像 docker pull mysql 运行 docker run -p 3306:3306 --name mysql -v /mysql/conf:/etc/mysql/conf.d -v /mysql/logs:/logs -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=你的密码 -d mysql:5.7\r开启运程登录权限 登录数据库\nmysql -uroot -p 分配权限\nGRANT ALL ON *.* TO 'root'@'%' IDENTIFIED BY \u0026quot;密码\u0026quot; ;\r刷新权限\nFLUSH PRIVILEGES ;\r","date":1592953200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592953200,"objectID":"5a2f73270da0f35b04b710baa427c94e","permalink":"https://academia-hugo.netlify.com/notes/docker-study/%E5%AE%89%E8%A3%85mysql/","publishdate":"2020-06-24T00:00:00+01:00","relpermalink":"/notes/docker-study/%E5%AE%89%E8%A3%85mysql/","section":"notes","summary":"拉取镜像 docker pull mysql 运行 docker run -p 3306:3306 --name mysql -v /mysql/conf:/etc/mysql/conf.d -v /mysql/logs:/logs -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=你的密码 -d mysql:5.7\r开启运程登录权限 登录数据库\nmysql -uroot -p 分配权限\nGRANT ALL ON *.* TO 'root'@'%' IDENTIFIED BY \u0026quot;密码\u0026quot; ;\r刷新权限\nFLUSH PRIVILEGES ;\r","tags":null,"title":"安装MySQL","type":"docs"},{"authors":null,"categories":null,"content":"docker数据卷（数据持久化） 1.命令 docke run -it -v /宿主机绝对目录 : /容貌内目录 镜像名 2.查看数据是否挂载成功 3.容器与数据之间数据共享 4.容器停止后。主机修改后数据是否同步\n数据之间数据共享 查看容器镜像 查看宿主机根目录 docker run -d -it -v /tomcatvolume:/usr/local/tomcat/logs tomcat:7 此时对比宿主机和容器\n宿主机\n容器\n查看数据是否挂载成功 docker inspect 90b560cb23f5 容器停止后。主机修改后数据是否同步 step1 这时我们可以在宿主机上新建一个test.txt 文件\n宿主机 容器\nstep2 重启容器\ndocker restart 90b560cb23f5 查看容器/tomcat/logs下的文件发现文件依然存在\ndocker file实现 编写dockerFile\nvim dockerfile 输入以下内容\nFROM tomcat VOLUME [\u0026#34;/dataVolumContainer1\u0026#34;,\u0026#34;/dataVolumContainer2\u0026#34;] CMD echo \u0026#34;success!!!!!\u0026#34; CMD /bin/bash 构建容器（官方文档：https://docs.docker.com/get-started/part2/）\ndocker build --tag dockerfile . 运行镜像\ndocker run -it cb368229b4ab 数据卷容器 命名的数据挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。 实验步骤： 1.创建一个父容器d01 2.d02/d03j继承d01 3.删除d01后查看d02和d03能否访问\n创建父类 docker run -it -d --name d01 cb368229b4ab d02/d03j继承d01 d02继承d01容器\ndocker run -it -d --name d02 --volumes-from d01 cb368229b4ab d03继承d01 d01(父容器)新增文件 d01: d02: d03: 结论：父容器可以跟子容器数据共享\nd02新增文件 d01 d02 d03: 结论：子容器可以跟父容器数据共享\n删除d01容器 d02: d03: 结论：父容器删除后子容器依然存在\n","date":1592434800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592434800,"objectID":"8c7d760ab1c2b1749a260582986de9db","permalink":"https://academia-hugo.netlify.com/notes/docker-study/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/","publishdate":"2020-06-18T00:00:00+01:00","relpermalink":"/notes/docker-study/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/","section":"notes","summary":"docker数据卷（数据持久化） 1.命令 docke run -it -v /宿主机绝对目录 : /容貌内目录 镜像名 2.查看数据是否挂载成功 3.容器与数据之间数据共享 4.容器停止后。主机修改后数据是否同步\n数据之间数据共享 查看容器镜像 查看宿主机根目录 docker run -d -it -v /tomcatvolume:/usr/local/tomcat/logs tomcat:7 此时对比宿主机和容器\n宿主机\n容器\n查看数据是否挂载成功 docker inspect 90b560cb23f5 容器停止后。主机修改后数据是否同步 step1 这时我们可以在宿主机上新建一个test.txt 文件\n宿主机 容器\nstep2 重启容器\ndocker restart 90b560cb23f5 查看容器/tomcat/logs下的文件发现文件依然存在\ndocker file实现 编写dockerFile\nvim dockerfile 输入以下内容\nFROM tomcat VOLUME [\u0026#34;/dataVolumContainer1\u0026#34;,\u0026#34;/dataVolumContainer2\u0026#34;] CMD echo \u0026#34;success!!!!!\u0026#34; CMD /bin/bash 构建容器（官方文档：https://docs.docker.com/get-started/part2/）\ndocker build --tag dockerfile . 运行镜像\ndocker run -it cb368229b4ab 数据卷容器 命名的数据挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。 实验步骤： 1.","tags":null,"title":"docker数据卷","type":"docs"},{"authors":null,"categories":null,"content":"安装cadvisor docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/apps/docker/:/var/lib/docker:ro --volume=/dev/disk/:/dev/disk:ro --publish=9101:8080 --detach=true --name=cadvisor google/cadvisor:latest 修改prometheus配置  - job_name: docker static_configs: - targets: ['203.176.95.155:9101']\r可视化 docker 监控仪表盘193\n","date":1592262000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592262000,"objectID":"80b9ed4fe478ddf6fd6fc694cc7d39dd","permalink":"https://academia-hugo.netlify.com/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7docker/","publishdate":"2020-06-16T00:00:00+01:00","relpermalink":"/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7docker/","section":"notes","summary":"安装cadvisor docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/apps/docker/:/var/lib/docker:ro --volume=/dev/disk/:/dev/disk:ro --publish=9101:8080 --detach=true --name=cadvisor google/cadvisor:latest 修改prometheus配置  - job_name: docker static_configs: - targets: ['203.176.95.155:9101']\r可视化 docker 监控仪表盘193","tags":null,"title":"普罗米修斯监控docker","type":"docs"},{"authors":null,"categories":null,"content":"官网https://github.com/percona/grafana-dashboards\n","date":1592262000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592262000,"objectID":"d2e63be26b9cd8d6833410d52a37473c","permalink":"https://academia-hugo.netlify.com/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7mysql/","publishdate":"2020-06-16T00:00:00+01:00","relpermalink":"/notes/prometheus/%E6%99%AE%E7%BD%97%E7%B1%B3%E4%BF%AE%E6%96%AF%E7%9B%91%E6%8E%A7mysql/","section":"notes","summary":"官网https://github.com/percona/grafana-dashboards","tags":null,"title":"普罗米修斯监控MYSQL","type":"docs"},{"authors":null,"categories":null,"content":"拉取Tomcat镜像 docker pull tomcat 运行tomcat 将宿主机的8081端口指向到容器的8080端口\ndocker run -d --name tomcat -p 8081:8080 tomcat 发现Tomcat已经启动了但是访问不了\n进入交互模式发现webapps是空的，资源都在webapps.dist下\ndocker exec -it 926d769607f4 /bin/bash 将webapps.dist下的所有文件复制到webapps\ncp -R webapps.dist/* webapps 再次访问成功！！！！！ ","date":1592175600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592175600,"objectID":"9f50e174faccd6805704ff00bac27c91","permalink":"https://academia-hugo.netlify.com/notes/docker-study/docker%E9%85%8D%E7%BD%AEtomcat/","publishdate":"2020-06-15T00:00:00+01:00","relpermalink":"/notes/docker-study/docker%E9%85%8D%E7%BD%AEtomcat/","section":"notes","summary":"拉取Tomcat镜像 docker pull tomcat 运行tomcat 将宿主机的8081端口指向到容器的8080端口\ndocker run -d --name tomcat -p 8081:8080 tomcat 发现Tomcat已经启动了但是访问不了\n进入交互模式发现webapps是空的，资源都在webapps.dist下\ndocker exec -it 926d769607f4 /bin/bash 将webapps.dist下的所有文件复制到webapps\ncp -R webapps.dist/* webapps 再次访问成功！！！！！ ","tags":null,"title":"配置Tomcat","type":"docs"},{"authors":null,"categories":null,"content":"注册阿里云账号 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n复制加速地址\n编辑配置文件 vim /etc/docker/daemon.json 添加如下内容\n{/ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://****.mirror.aliyuncs.com\u0026#34;] } 重启docker服务 systemctl daemon-reload systemctl restart docker 检查 docker info 配置成功！！！！\n","date":1590188400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590188400,"objectID":"27f22c75d548722cb89ffaec7b996e8a","permalink":"https://academia-hugo.netlify.com/notes/docker-study/%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/","publishdate":"2020-05-23T00:00:00+01:00","relpermalink":"/notes/docker-study/%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/","section":"notes","summary":"注册阿里云账号 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n复制加速地址\n编辑配置文件 vim /etc/docker/daemon.json 添加如下内容\n{/ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://****.mirror.aliyuncs.com\u0026#34;] } 重启docker服务 systemctl daemon-reload systemctl restart docker 检查 docker info 配置成功！！！！","tags":null,"title":"配置阿里云镜像加速地址","type":"docs"},{"authors":[],"categories":[],"content":"Welcome to Slides academia\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\rPress Space to play!\nOne Two Three  A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/img/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://academia-hugo.netlify.com/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using academia's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"https://academia-hugo.netlify.com/privacy/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/privacy/","section":"","summary":"","tags":null,"title":"","type":"page"},{"authors":null,"categories":null,"content":"POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 新建bootstrap.yml\nserver:\rport: 3355\rspring:\rapplication:\rname: config-client\rcloud:\rconfig:\rlabel: master name: config profile: dev uri: http://localhost:3344 eureka:\rclient:\rservice-url:\rdefaultZone: http://localhost:7001/eureka\r命名规则\n启动类 package com.cloud.config; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class ConfigClientMain3355 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3355.class, args); } } 测试 controller\npackage com.cloud.config.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; /** * * @author yzg * @version 1.0 * @create 2020/08/04 */ @RestController @RefreshScope public class ConfigClientController { @Value(\u0026#34;${config.info}\u0026#34;) private String configInfo; @GetMapping(\u0026#34;/configInfo\u0026#34;) public String getConfigInfo(){ return configInfo; } } 测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n访问http://localhost:3355/configInfo\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"fea6affc4259b1d6c8656bd529b3e775","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/config%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/cloud-study/config%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/","section":"notes","summary":"POM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 新建bootstrap.yml\nserver:\rport: 3355\rspring:\rapplication:\rname: config-client\rcloud:\rconfig:\rlabel: master name: config profile: dev uri: http://localhost:3344 eureka:\rclient:\rservice-url:\rdefaultZone: http://localhost:7001/eureka\r命名规则\n启动类 package com.cloud.config; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class ConfigClientMain3355 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3355.class, args); } } 测试 controller\npackage com.cloud.config.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; /** * * @author yzg * @version 1.","tags":null,"title":"config客户端配置","type":"docs"},{"authors":null,"categories":null,"content":"编辑项目 cloud-config-client-3355\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 新建以下配置\nmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot;\rcontroller 添加@RefreshScope注解\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n访问http://localhost:3355/configInfo\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=2\u0026quot;\r再次访问http://localhost:3355/configInfo\n客户端发送POST请求curl -X POST \u0026ldquo;http://localhost:3355/actuator/refresh\u0026rdquo;\n再次访问http://localhost:3355/configInfo\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"acfe97aa564532ff117d4139d6c82f15","permalink":"https://academia-hugo.netlify.com/notes/cloud-study/config%E6%89%8B%E5%8A%A8%E5%88%B7%E6%96%B0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/cloud-study/config%E6%89%8B%E5%8A%A8%E5%88%B7%E6%96%B0/","section":"notes","summary":"编辑项目 cloud-config-client-3355\nPOM \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; YML 新建以下配置\nmanagement:\rendpoints:\rweb:\rexposure:\rinclude: \u0026quot;*\u0026quot;\rcontroller 添加@RefreshScope注解\n测试 运行cloud-eureka-server7001\n运行cloud-eureka-server7002\n运行cloud-config-center-3344\n运行cloud-config-client-3355\n访问http://localhost:3355/configInfo\n修改gitee上的config-dev.yml文件\nconfig: info: \u0026quot;master Branches cloud2020_config/config-dev-yml v=2\u0026quot;\r再次访问http://localhost:3355/configInfo\n客户端发送POST请求curl -X POST \u0026ldquo;http://localhost:3355/actuator/refresh\u0026rdquo;\n再次访问http://localhost:3355/configInfo","tags":null,"title":"config手动刷新","type":"docs"},{"authors":null,"categories":null,"content":"GitLab 简介 GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"d118803205d54639f2d4b4e886c67a7a","permalink":"https://academia-hugo.netlify.com/notes/paas-study/gitlab/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/paas-study/gitlab/","section":"notes","summary":"GitLab 简介 GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。","tags":null,"title":"GitLab仓库管理系统","type":"docs"}]